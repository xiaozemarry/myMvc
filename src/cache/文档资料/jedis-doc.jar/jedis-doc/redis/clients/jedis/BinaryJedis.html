<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_24) on Fri Apr 15 15:01:46 CST 2011 -->
<TITLE>
BinaryJedis (jedis 1.5.0 API)
</TITLE>

<META NAME="date" CONTENT="2011-04-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="BinaryJedis (jedis 1.5.0 API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../redis/clients/jedis/BinaryClient.LIST_POSITION.html" title="enum in redis.clients.jedis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?redis/clients/jedis/BinaryJedis.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BinaryJedis.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
redis.clients.jedis</FONT>
<BR>
Class BinaryJedis</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>redis.clients.jedis.BinaryJedis</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../redis/clients/jedis/Jedis.html" title="class in redis.clients.jedis">Jedis</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>BinaryJedis</B><DT>extends java.lang.Object<DT>implements <A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></DL>
</PRE>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../redis/clients/jedis/Client.html" title="class in redis.clients.jedis">Client</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#client">client</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#BinaryJedis(redis.clients.jedis.JedisShardInfo)">BinaryJedis</A></B>(<A HREF="../../../redis/clients/jedis/JedisShardInfo.html" title="class in redis.clients.jedis">JedisShardInfo</A>&nbsp;shardInfo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#BinaryJedis(java.lang.String)">BinaryJedis</A></B>(java.lang.String&nbsp;host)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#BinaryJedis(java.lang.String, int)">BinaryJedis</A></B>(java.lang.String&nbsp;host,
            int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#BinaryJedis(java.lang.String, int, int)">BinaryJedis</A></B>(java.lang.String&nbsp;host,
            int&nbsp;port,
            int&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#append(byte[], byte[])">append</A></B>(byte[]&nbsp;key,
       byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the key already exists and is a string, this command appends the
 provided value at the end of the string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#auth(java.lang.String)">auth</A></B>(java.lang.String&nbsp;password)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Request for authentication in a password protected Redis server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#bgrewriteaof()">bgrewriteaof</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rewrite the append only file in background when it gets too big.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#bgsave()">bgsave</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously save the DB on disk.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#blpop(int, byte[]...)">blpop</A></B>(int&nbsp;timeout,
      byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BLPOP (and BRPOP) is a blocking list pop primitive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#brpop(int, byte[]...)">brpop</A></B>(int&nbsp;timeout,
      byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BLPOP (and BRPOP) is a blocking list pop primitive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#brpoplpush(byte[], byte[], int)">brpoplpush</A></B>(byte[]&nbsp;source,
           byte[]&nbsp;destination,
           int&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pop a value from a list, push it to another list and return it; or block
 until one is available</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#checkIsInMulti()">checkIsInMulti</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#configGet(java.lang.String)">configGet</A></B>(java.lang.String&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve the configuration of a running Redis server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#configResetStat()">configResetStat</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reset the stats returned by INFO</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#configSet(java.lang.String, java.lang.String)">configSet</A></B>(java.lang.String&nbsp;parameter,
          java.lang.String&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alter the configuration of a running Redis server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#connect()">connect</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#dbSize()">dbSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the number of keys in the currently selected database.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#debug(redis.clients.jedis.DebugParams)">debug</A></B>(<A HREF="../../../redis/clients/jedis/DebugParams.html" title="class in redis.clients.jedis">DebugParams</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#decr(byte[])">decr</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the number stored at key by one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#decrBy(byte[], long)">decrBy</A></B>(byte[]&nbsp;key,
       long&nbsp;integer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IDECRBY work just like <CODE>INCR</CODE> but instead to
 decrement by 1 the decrement is integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#del(byte[]...)">del</A></B>(byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the specified keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#disconnect()">disconnect</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#echo(byte[])">echo</A></B>(byte[]&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#exists(byte[])">exists</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test if the specified key exists.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#expire(byte[], int)">expire</A></B>(byte[]&nbsp;key,
       int&nbsp;seconds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a timeout on the specified key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#expireAt(byte[], long)">expireAt</A></B>(byte[]&nbsp;key,
         long&nbsp;unixTime)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXPIREAT works exctly like <CODE>EXPIRE</CODE> but
 instead to get the number of seconds representing the Time To Live of the
 key as a second argument (that is a relative way of specifing the TTL),
 it takes an absolute one in the form of a UNIX timestamp (Number of
 seconds elapsed since 1 Gen 1970).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#flushAll()">flushAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete all the keys of all the existing databases, not just the currently
 selected one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#flushDB()">flushDB</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete all the keys of the currently selected DB.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#get(byte[])">get</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the value of the specified key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#getbit(byte[], long)">getbit</A></B>(byte[]&nbsp;key,
       long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bit value at offset in the string value stored at key</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../redis/clients/jedis/Client.html" title="class in redis.clients.jedis">Client</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#getClient()">getClient</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#getrange(byte[], long, long)">getrange</A></B>(byte[]&nbsp;key,
         long&nbsp;startOffset,
         long&nbsp;endOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#getSet(byte[], byte[])">getSet</A></B>(byte[]&nbsp;key,
       byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GETSET is an atomic set this value and return the old value command.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hdel(byte[], byte[])">hdel</A></B>(byte[]&nbsp;key,
     byte[]&nbsp;field)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the specified field from an hash stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hexists(byte[], byte[])">hexists</A></B>(byte[]&nbsp;key,
        byte[]&nbsp;field)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test for existence of a specified field in a hash.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hget(byte[], byte[])">hget</A></B>(byte[]&nbsp;key,
     byte[]&nbsp;field)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If key holds a hash, retrieve the value associated to the specified
 field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;byte[],byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hgetAll(byte[])">hgetAll</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return all the fields and associated values in a hash.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hincrBy(byte[], byte[], long)">hincrBy</A></B>(byte[]&nbsp;key,
        byte[]&nbsp;field,
        long&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the number stored at field in the hash at key by value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hkeys(byte[])">hkeys</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return all the fields in a hash.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hlen(byte[])">hlen</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the number of items in a hash.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hmget(byte[], byte[]...)">hmget</A></B>(byte[]&nbsp;key,
      byte[]...&nbsp;fields)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve the values associated to the specified fields.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hmset(byte[], java.util.Map)">hmset</A></B>(byte[]&nbsp;key,
      java.util.Map&lt;byte[],byte[]&gt;&nbsp;hash)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the respective fields to the respective values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hset(byte[], byte[], byte[])">hset</A></B>(byte[]&nbsp;key,
     byte[]&nbsp;field,
     byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the specified hash field to the specified value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hsetnx(byte[], byte[], byte[])">hsetnx</A></B>(byte[]&nbsp;key,
       byte[]&nbsp;field,
       byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the specified hash field to the specified value if the field not
 exists.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#hvals(byte[])">hvals</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return all the values in a hash.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#incr(byte[])">incr</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the number stored at key by one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#incrBy(byte[], long)">incrBy</A></B>(byte[]&nbsp;key,
       long&nbsp;integer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INCRBY work just like <CODE>INCR</CODE> but instead to increment
 by 1 the increment is integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#info()">info</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provide information and statistics about the server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#isConnected()">isConnected</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#keys(byte[])">keys</A></B>(byte[]&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all the keys matching the glob-style pattern as space separated
 strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lastsave()">lastsave</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the UNIX time stamp of the last successfully saving of the dataset
 on disk.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lindex(byte[], int)">lindex</A></B>(byte[]&nbsp;key,
       int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the specified element of the list stored at the specified key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#linsert(byte[], redis.clients.jedis.BinaryClient.LIST_POSITION, byte[], byte[])">linsert</A></B>(byte[]&nbsp;key,
        <A HREF="../../../redis/clients/jedis/BinaryClient.LIST_POSITION.html" title="enum in redis.clients.jedis">BinaryClient.LIST_POSITION</A>&nbsp;where,
        byte[]&nbsp;pivot,
        byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#llen(byte[])">llen</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the length of the list stored at the specified key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lpop(byte[])">lpop</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically return and remove the first (LPOP) or last (RPOP) element of
 the list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lpush(byte[], byte[])">lpush</A></B>(byte[]&nbsp;key,
      byte[]&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add the string value to the head (LPUSH) or tail (RPUSH) of the list
 stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lpushx(byte[], byte[])">lpushx</A></B>(byte[]&nbsp;key,
       byte[]&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lrange(byte[], int, int)">lrange</A></B>(byte[]&nbsp;key,
       int&nbsp;start,
       int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the specified elements of the list stored at the specified key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lrem(byte[], int, byte[])">lrem</A></B>(byte[]&nbsp;key,
     int&nbsp;count,
     byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the first count occurrences of the value element from the list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#lset(byte[], int, byte[])">lset</A></B>(byte[]&nbsp;key,
     int&nbsp;index,
     byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a new value as the element at index position of the List at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#ltrim(byte[], int, int)">ltrim</A></B>(byte[]&nbsp;key,
      int&nbsp;start,
      int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trim an existing list so that it will contain only the specified range of
 elements specified.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#mget(byte[]...)">mget</A></B>(byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values of all the specified keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#monitor(redis.clients.jedis.JedisMonitor)">monitor</A></B>(<A HREF="../../../redis/clients/jedis/JedisMonitor.html" title="class in redis.clients.jedis">JedisMonitor</A>&nbsp;jedisMonitor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dump all the received requests in real time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#move(byte[], int)">move</A></B>(byte[]&nbsp;key,
     int&nbsp;dbIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move the specified key from the currently selected DB to the specified
 destination DB.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#mset(byte[]...)">mset</A></B>(byte[]...&nbsp;keysvalues)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the the respective keys to the respective values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#msetnx(byte[]...)">msetnx</A></B>(byte[]...&nbsp;keysvalues)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the the respective keys to the respective values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../redis/clients/jedis/Transaction.html" title="class in redis.clients.jedis">Transaction</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#multi()">multi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#multi(redis.clients.jedis.TransactionBlock)">multi</A></B>(<A HREF="../../../redis/clients/jedis/TransactionBlock.html" title="class in redis.clients.jedis">TransactionBlock</A>&nbsp;jedisTransaction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#persist(byte[])">persist</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undo a <CODE>expire</CODE> at turning the expire key into
 a normal key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#ping()">ping</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../redis/clients/jedis/Pipeline.html" title="class in redis.clients.jedis">Pipeline</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#pipelined()">pipelined</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#pipelined(redis.clients.jedis.PipelineBlock)">pipelined</A></B>(<A HREF="../../../redis/clients/jedis/PipelineBlock.html" title="class in redis.clients.jedis">PipelineBlock</A>&nbsp;jedisPipeline)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#psubscribe(redis.clients.jedis.BinaryJedisPubSub, byte[]...)">psubscribe</A></B>(<A HREF="../../../redis/clients/jedis/BinaryJedisPubSub.html" title="class in redis.clients.jedis">BinaryJedisPubSub</A>&nbsp;jedisPubSub,
           byte[]...&nbsp;patterns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#psubscribe(redis.clients.jedis.JedisPubSub, java.lang.String...)">psubscribe</A></B>(<A HREF="../../../redis/clients/jedis/JedisPubSub.html" title="class in redis.clients.jedis">JedisPubSub</A>&nbsp;jedisPubSub,
           java.lang.String...&nbsp;patterns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#publish(byte[], byte[])">publish</A></B>(byte[]&nbsp;channel,
        byte[]&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#publish(java.lang.String, java.lang.String)">publish</A></B>(java.lang.String&nbsp;channel,
        java.lang.String&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#quit()">quit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ask the server to silently close the connection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#randomBinaryKey()">randomBinaryKey</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a randomly selected key from the currently selected DB.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#rename(byte[], byte[])">rename</A></B>(byte[]&nbsp;oldkey,
       byte[]&nbsp;newkey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically renames the key oldkey to newkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#renamenx(byte[], byte[])">renamenx</A></B>(byte[]&nbsp;oldkey,
         byte[]&nbsp;newkey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rename oldkey into newkey but fails if the destination key newkey already
 exists.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#rpop(byte[])">rpop</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically return and remove the first (LPOP) or last (RPOP) element of
 the list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#rpoplpush(byte[], byte[])">rpoplpush</A></B>(byte[]&nbsp;srckey,
          byte[]&nbsp;dstkey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically return and remove the last (tail) element of the srckey list,
 and push the element as the first (head) element of the dstkey list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#rpush(byte[], byte[])">rpush</A></B>(byte[]&nbsp;key,
      byte[]&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add the string value to the head (LPUSH) or tail (RPUSH) of the list
 stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#rpushx(byte[], byte[])">rpushx</A></B>(byte[]&nbsp;key,
       byte[]&nbsp;string)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sadd(byte[], byte[])">sadd</A></B>(byte[]&nbsp;key,
     byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add the specified member to the set value stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#save()">save</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synchronously save the DB on disk.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#scard(byte[])">scard</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the set cardinality (number of elements).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sdiff(byte[]...)">sdiff</A></B>(byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the difference between the Set stored at key1 and all the Sets
 key2, ..., keyN</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sdiffstore(byte[], byte[]...)">sdiffstore</A></B>(byte[]&nbsp;dstkey,
           byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This command works exactly like <CODE>SDIFF</CODE> but
 instead of being returned the resulting set is stored in dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#select(int)">select</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select the DB with having the specified zero-based numeric index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#set(byte[], byte[])">set</A></B>(byte[]&nbsp;key,
    byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the string value as value of the key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#setbit(byte[], long, byte[])">setbit</A></B>(byte[]&nbsp;key,
       long&nbsp;offset,
       byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets or clears the bit at offset in the string value stored at key</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#setex(byte[], int, byte[])">setex</A></B>(byte[]&nbsp;key,
      int&nbsp;seconds,
      byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The command is exactly equivalent to the following group of commands:
 <CODE>SET</CODE> + <CODE>EXPIRE</CODE>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#setnx(byte[], byte[])">setnx</A></B>(byte[]&nbsp;key,
      byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SETNX works exactly like <CODE>SET</CODE> with the only
 difference that if the key already exists no operation is performed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#setrange(byte[], long, byte[])">setrange</A></B>(byte[]&nbsp;key,
         long&nbsp;offset,
         byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synchronously save the DB on disk, then shutdown the server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sinter(byte[]...)">sinter</A></B>(byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the members of a set resulting from the intersection of all the
 sets hold at the specified keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sinterstore(byte[], byte[]...)">sinterstore</A></B>(byte[]&nbsp;dstkey,
            byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This commnad works exactly like <CODE>SINTER</CODE> but
 instead of being returned the resulting set is sotred as dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sismember(byte[], byte[])">sismember</A></B>(byte[]&nbsp;key,
          byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return 1 if member is a member of the set stored at key, otherwise 0 is
 returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#slaveof(java.lang.String, int)">slaveof</A></B>(java.lang.String&nbsp;host,
        int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change the replication settings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#slaveofNoOne()">slaveofNoOne</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#smembers(byte[])">smembers</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return all the members (elements) of the set value stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#smove(byte[], byte[], byte[])">smove</A></B>(byte[]&nbsp;srckey,
      byte[]&nbsp;dstkey,
      byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move the specifided member from the set at srckey to the set at dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sort(byte[])">sort</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a Set or a List.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sort(byte[], byte[])">sort</A></B>(byte[]&nbsp;key,
     byte[]&nbsp;dstkey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a Set or a List and Store the Result at dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sort(byte[], redis.clients.jedis.SortingParams)">sort</A></B>(byte[]&nbsp;key,
     <A HREF="../../../redis/clients/jedis/SortingParams.html" title="class in redis.clients.jedis">SortingParams</A>&nbsp;sortingParameters)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a Set or a List accordingly to the specified parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sort(byte[], redis.clients.jedis.SortingParams, byte[])">sort</A></B>(byte[]&nbsp;key,
     <A HREF="../../../redis/clients/jedis/SortingParams.html" title="class in redis.clients.jedis">SortingParams</A>&nbsp;sortingParameters,
     byte[]&nbsp;dstkey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a Set or a List accordingly to the specified parameters and store
 the result at dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#spop(byte[])">spop</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove a random element from a Set returning it as return value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#srandmember(byte[])">srandmember</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a random element from a Set, without removing the element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#srem(byte[], byte[])">srem</A></B>(byte[]&nbsp;key,
     byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the specified member from the set value stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#strlen(byte[])">strlen</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#subscribe(redis.clients.jedis.BinaryJedisPubSub, byte[]...)">subscribe</A></B>(<A HREF="../../../redis/clients/jedis/BinaryJedisPubSub.html" title="class in redis.clients.jedis">BinaryJedisPubSub</A>&nbsp;jedisPubSub,
          byte[]...&nbsp;channels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#subscribe(redis.clients.jedis.JedisPubSub, java.lang.String...)">subscribe</A></B>(<A HREF="../../../redis/clients/jedis/JedisPubSub.html" title="class in redis.clients.jedis">JedisPubSub</A>&nbsp;jedisPubSub,
          java.lang.String...&nbsp;channels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#substr(byte[], int, int)">substr</A></B>(byte[]&nbsp;key,
       int&nbsp;start,
       int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a subset of the string from offset start to offset end (both
 offsets are inclusive).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sunion(byte[]...)">sunion</A></B>(byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the members of a set resulting from the union of all the sets hold
 at the specified keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sunionstore(byte[], byte[]...)">sunionstore</A></B>(byte[]&nbsp;dstkey,
            byte[]...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This command works exactly like <CODE>SUNION</CODE> but
 instead of being returned the resulting set is stored as dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#sync()">sync</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#ttl(byte[])">ttl</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The TTL command returns the remaining time to live in seconds of a key
 that has an <CODE>EXPIRE</CODE> set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#type(byte[])">type</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the type of the value stored at key in form of a string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#unwatch()">unwatch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#watch(byte[])">watch</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zadd(byte[], double, byte[])">zadd</A></B>(byte[]&nbsp;key,
     double&nbsp;score,
     byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add the specified member having the specifeid score to the sorted set
 stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zcard(byte[])">zcard</A></B>(byte[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the sorted set cardinality (number of elements).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zcount(byte[], double, double)">zcount</A></B>(byte[]&nbsp;key,
       double&nbsp;min,
       double&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zincrby(byte[], double, byte[])">zincrby</A></B>(byte[]&nbsp;key,
        double&nbsp;score,
        byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If member already exists in the sorted set adds the increment to its
 score and updates the position of the element in the sorted set
 accordingly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zinterstore(byte[], byte[]...)">zinterstore</A></B>(byte[]&nbsp;dstkey,
            byte[]...&nbsp;sets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zinterstore(byte[], redis.clients.jedis.ZParams, byte[]...)">zinterstore</A></B>(byte[]&nbsp;dstkey,
            <A HREF="../../../redis/clients/jedis/ZParams.html" title="class in redis.clients.jedis">ZParams</A>&nbsp;params,
            byte[]...&nbsp;sets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrange(byte[], int, int)">zrange</A></B>(byte[]&nbsp;key,
       int&nbsp;start,
       int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrangeByScore(byte[], byte[], byte[])">zrangeByScore</A></B>(byte[]&nbsp;key,
              byte[]&nbsp;min,
              byte[]&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrangeByScore(byte[], double, double)">zrangeByScore</A></B>(byte[]&nbsp;key,
              double&nbsp;min,
              double&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrangeByScore(byte[], double, double, int, int)">zrangeByScore</A></B>(byte[]&nbsp;key,
              double&nbsp;min,
              double&nbsp;max,
              int&nbsp;offset,
              int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrangeByScoreWithScores(byte[], double, double)">zrangeByScoreWithScores</A></B>(byte[]&nbsp;key,
                        double&nbsp;min,
                        double&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrangeByScoreWithScores(byte[], double, double, int, int)">zrangeByScoreWithScores</A></B>(byte[]&nbsp;key,
                        double&nbsp;min,
                        double&nbsp;max,
                        int&nbsp;offset,
                        int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrangeWithScores(byte[], int, int)">zrangeWithScores</A></B>(byte[]&nbsp;key,
                 int&nbsp;start,
                 int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrank(byte[], byte[])">zrank</A></B>(byte[]&nbsp;key,
      byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the rank (or index) or member in the sorted set at key, with
 scores being ordered from low to high.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrem(byte[], byte[])">zrem</A></B>(byte[]&nbsp;key,
     byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the specified member from the sorted set value stored at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zremrangeByRank(byte[], int, int)">zremrangeByRank</A></B>(byte[]&nbsp;key,
                int&nbsp;start,
                int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove all elements in the sorted set at key with rank between start and
 end.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zremrangeByScore(byte[], double, double)">zremrangeByScore</A></B>(byte[]&nbsp;key,
                 double&nbsp;start,
                 double&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove all the elements in the sorted set at key with a score between min
 and max (including elements with score equal to min or max).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrange(byte[], int, int)">zrevrange</A></B>(byte[]&nbsp;key,
          int&nbsp;start,
          int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrangeByScore(byte[], byte[], byte[])">zrevrangeByScore</A></B>(byte[]&nbsp;key,
                 byte[]&nbsp;max,
                 byte[]&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrangeByScore(byte[], double, double)">zrevrangeByScore</A></B>(byte[]&nbsp;key,
                 double&nbsp;max,
                 double&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrangeByScore(byte[], double, double, int, int)">zrevrangeByScore</A></B>(byte[]&nbsp;key,
                 double&nbsp;max,
                 double&nbsp;min,
                 int&nbsp;offset,
                 int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrangeByScoreWithScores(byte[], double, double)">zrevrangeByScoreWithScores</A></B>(byte[]&nbsp;key,
                           double&nbsp;max,
                           double&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrangeByScoreWithScores(byte[], double, double, int, int)">zrevrangeByScoreWithScores</A></B>(byte[]&nbsp;key,
                           double&nbsp;max,
                           double&nbsp;min,
                           int&nbsp;offset,
                           int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrangeWithScores(byte[], int, int)">zrevrangeWithScores</A></B>(byte[]&nbsp;key,
                    int&nbsp;start,
                    int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zrevrank(byte[], byte[])">zrevrank</A></B>(byte[]&nbsp;key,
         byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the rank (or index) or member in the sorted set at key, with
 scores being ordered from high to low.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zscore(byte[], byte[])">zscore</A></B>(byte[]&nbsp;key,
       byte[]&nbsp;member)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the score of the specified element of the sorted set at key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zunionstore(byte[], byte[]...)">zunionstore</A></B>(byte[]&nbsp;dstkey,
            byte[]...&nbsp;sets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../redis/clients/jedis/BinaryJedis.html#zunionstore(byte[], redis.clients.jedis.ZParams, byte[]...)">zunionstore</A></B>(byte[]&nbsp;dstkey,
            <A HREF="../../../redis/clients/jedis/ZParams.html" title="class in redis.clients.jedis">ZParams</A>&nbsp;params,
            byte[]...&nbsp;sets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="client"><!-- --></A><H3>
client</H3>
<PRE>
protected <A HREF="../../../redis/clients/jedis/Client.html" title="class in redis.clients.jedis">Client</A> <B>client</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BinaryJedis(java.lang.String)"><!-- --></A><H3>
BinaryJedis</H3>
<PRE>
public <B>BinaryJedis</B>(java.lang.String&nbsp;host)</PRE>
<DL>
</DL>
<HR>

<A NAME="BinaryJedis(java.lang.String, int)"><!-- --></A><H3>
BinaryJedis</H3>
<PRE>
public <B>BinaryJedis</B>(java.lang.String&nbsp;host,
                   int&nbsp;port)</PRE>
<DL>
</DL>
<HR>

<A NAME="BinaryJedis(java.lang.String, int, int)"><!-- --></A><H3>
BinaryJedis</H3>
<PRE>
public <B>BinaryJedis</B>(java.lang.String&nbsp;host,
                   int&nbsp;port,
                   int&nbsp;timeout)</PRE>
<DL>
</DL>
<HR>

<A NAME="BinaryJedis(redis.clients.jedis.JedisShardInfo)"><!-- --></A><H3>
BinaryJedis</H3>
<PRE>
public <B>BinaryJedis</B>(<A HREF="../../../redis/clients/jedis/JedisShardInfo.html" title="class in redis.clients.jedis">JedisShardInfo</A>&nbsp;shardInfo)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ping()"><!-- --></A><H3>
ping</H3>
<PRE>
public java.lang.String <B>ping</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="set(byte[], byte[])"><!-- --></A><H3>
set</H3>
<PRE>
public java.lang.String <B>set</B>(byte[]&nbsp;key,
                            byte[]&nbsp;value)</PRE>
<DL>
<DD>Set the string value as value of the key. The string can't be longer than
 1073741824 bytes (1 GB).
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#set(byte[], byte[])">set</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="get(byte[])"><!-- --></A><H3>
get</H3>
<PRE>
public byte[] <B>get</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Get the value of the specified key. If the key does not exist the special
 value 'nil' is returned. If the value stored at key is not a string an
 error is returned because GET can only handle string values.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#get(byte[])">get</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="quit()"><!-- --></A><H3>
quit</H3>
<PRE>
public void <B>quit</B>()</PRE>
<DL>
<DD>Ask the server to silently close the connection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="exists(byte[])"><!-- --></A><H3>
exists</H3>
<PRE>
public java.lang.Boolean <B>exists</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Test if the specified key exists. The command returns "0" if the key
 exists, otherwise "1" is returned. Note that even keys set with an empty
 string as value will return "1".
 
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#exists(byte[])">exists</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, "1" if the key exists, otherwise "0"</DL>
</DD>
</DL>
<HR>

<A NAME="del(byte[]...)"><!-- --></A><H3>
del</H3>
<PRE>
public java.lang.Long <B>del</B>(byte[]...&nbsp;keys)</PRE>
<DL>
<DD>Remove the specified keys. If a given key does not exist no operation is
 performed for this key. The command returns the number of keys removed.
 
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: an integer greater than 0 if one or
         more keys were removed 0 if none of the specified key existed</DL>
</DD>
</DL>
<HR>

<A NAME="type(byte[])"><!-- --></A><H3>
type</H3>
<PRE>
public java.lang.String <B>type</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return the type of the value stored at key in form of a string. The type
 can be one of "none", "string", "list", "set". "none" is returned if the
 key does not exist.
 
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#type(byte[])">type</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Status code reply, specifically: "none" if the key does not exist
         "string" if the key contains a String value "list" if the key
         contains a List value "set" if the key contains a Set value
         "zset" if the key contains a Sorted Set value "hash" if the key
         contains a Hash value</DL>
</DD>
</DL>
<HR>

<A NAME="flushDB()"><!-- --></A><H3>
flushDB</H3>
<PRE>
public java.lang.String <B>flushDB</B>()</PRE>
<DL>
<DD>Delete all the keys of the currently selected DB. This command never
 fails.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="keys(byte[])"><!-- --></A><H3>
keys</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>keys</B>(byte[]&nbsp;pattern)</PRE>
<DL>
<DD>Returns all the keys matching the glob-style pattern as space separated
 strings. For example if you have in the database the keys "foo" and
 "foobar" the command "KEYS foo*" will return "foo foobar".
 <p>
 Note that while the time complexity for this operation is O(n) the
 constant times are pretty low. For example Redis running on an entry
 level laptop can scan a 1 million keys database in 40 milliseconds.
 <b>Still it's better to consider this one of the slow commands that may
 ruin the DB performance if not used with care.</b>
 <p>
 In other words this command is intended only for debugging and special
 operations like creating a script to change the DB schema. Don't use it
 in your normal code. Use Redis Sets in order to group together a subset
 of objects.
 <p>
 Glob style patterns examples:
 <ul>
 <li>h?llo will match hello hallo hhllo
 <li>h*llo will match hllo heeeello
 <li>h[ae]llo will match hello and hallo, but not hillo
 </ul>
 <p>
 Use \ to escape special chars if you want to match them verbatim.
 <p>
 Time complexity: O(n) (with n being the number of keys in the DB, and
 assuming keys and pattern of limited length)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="randomBinaryKey()"><!-- --></A><H3>
randomBinaryKey</H3>
<PRE>
public byte[] <B>randomBinaryKey</B>()</PRE>
<DL>
<DD>Return a randomly selected key from the currently selected DB.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Singe line reply, specifically the randomly selected key or an
         empty string is the database is empty</DL>
</DD>
</DL>
<HR>

<A NAME="rename(byte[], byte[])"><!-- --></A><H3>
rename</H3>
<PRE>
public java.lang.String <B>rename</B>(byte[]&nbsp;oldkey,
                               byte[]&nbsp;newkey)</PRE>
<DL>
<DD>Atomically renames the key oldkey to newkey. If the source and
 destination name are the same an error is returned. If newkey already
 exists it is overwritten.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldkey</CODE> - <DD><CODE>newkey</CODE> - 
<DT><B>Returns:</B><DD>Status code repy</DL>
</DD>
</DL>
<HR>

<A NAME="renamenx(byte[], byte[])"><!-- --></A><H3>
renamenx</H3>
<PRE>
public java.lang.Long <B>renamenx</B>(byte[]&nbsp;oldkey,
                               byte[]&nbsp;newkey)</PRE>
<DL>
<DD>Rename oldkey into newkey but fails if the destination key newkey already
 exists.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldkey</CODE> - <DD><CODE>newkey</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the key was renamed 0 if the
         target key already exist</DL>
</DD>
</DL>
<HR>

<A NAME="dbSize()"><!-- --></A><H3>
dbSize</H3>
<PRE>
public java.lang.Long <B>dbSize</B>()</PRE>
<DL>
<DD>Return the number of keys in the currently selected database.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Integer reply</DL>
</DD>
</DL>
<HR>

<A NAME="expire(byte[], int)"><!-- --></A><H3>
expire</H3>
<PRE>
public java.lang.Long <B>expire</B>(byte[]&nbsp;key,
                             int&nbsp;seconds)</PRE>
<DL>
<DD>Set a timeout on the specified key. After the timeout the key will be
 automatically deleted by the server. A key with an associated timeout is
 said to be volatile in Redis terminology.
 <p>
 Voltile keys are stored on disk like the other keys, the timeout is
 persistent too like all the other aspects of the dataset. Saving a
 dataset containing expires and stopping the server does not stop the flow
 of time as Redis stores on disk the time when the key will no longer be
 available as Unix time, and not the remaining seconds.
 <p>
 Since Redis 2.1.3 you can update the value of the timeout of a key
 already having an expire set. It is also possible to undo the expire at
 all turning the key into a normal key using the <CODE>PERSIST</CODE> command.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#expire(byte[], int)">expire</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>seconds</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1: the timeout was set. 0: the
         timeout was not set since the key already has an associated
         timeout (this may happen only in Redis versions < 2.1.3, Redis >=
         2.1.3 will happily update the timeout), or the key does not
         exist.<DT><B>See Also:</B><DD><ahref="http://code.google.com/p/redis/wiki/ExpireCommand">ExpireCommand</a></DL>
</DD>
</DL>
<HR>

<A NAME="expireAt(byte[], long)"><!-- --></A><H3>
expireAt</H3>
<PRE>
public java.lang.Long <B>expireAt</B>(byte[]&nbsp;key,
                               long&nbsp;unixTime)</PRE>
<DL>
<DD>EXPIREAT works exctly like <CODE>EXPIRE</CODE> but
 instead to get the number of seconds representing the Time To Live of the
 key as a second argument (that is a relative way of specifing the TTL),
 it takes an absolute one in the form of a UNIX timestamp (Number of
 seconds elapsed since 1 Gen 1970).
 <p>
 EXPIREAT was introduced in order to implement the Append Only File
 persistence mode so that EXPIRE commands are automatically translated
 into EXPIREAT commands for the append only file. Of course EXPIREAT can
 also used by programmers that need a way to simply specify that a given
 key should expire at a given time in the future.
 <p>
 Since Redis 2.1.3 you can update the value of the timeout of a key
 already having an expire set. It is also possible to undo the expire at
 all turning the key into a normal key using the <CODE>PERSIST</CODE> command.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#expireAt(byte[], long)">expireAt</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>unixTime</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1: the timeout was set. 0: the
         timeout was not set since the key already has an associated
         timeout (this may happen only in Redis versions < 2.1.3, Redis >=
         2.1.3 will happily update the timeout), or the key does not
         exist.<DT><B>See Also:</B><DD><ahref="http://code.google.com/p/redis/wiki/ExpireCommand">ExpireCommand</a></DL>
</DD>
</DL>
<HR>

<A NAME="ttl(byte[])"><!-- --></A><H3>
ttl</H3>
<PRE>
public java.lang.Long <B>ttl</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>The TTL command returns the remaining time to live in seconds of a key
 that has an <CODE>EXPIRE</CODE> set. This introspection
 capability allows a Redis client to check how many seconds a given key
 will continue to be part of the dataset.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#ttl(byte[])">ttl</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, returns the remaining time to live in seconds of a
         key that has an EXPIRE. If the Key does not exists or does not
         have an associated expire, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="select(int)"><!-- --></A><H3>
select</H3>
<PRE>
public java.lang.String <B>select</B>(int&nbsp;index)</PRE>
<DL>
<DD>Select the DB with having the specified zero-based numeric index. For
 default every new client connection is automatically selected to DB 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="move(byte[], int)"><!-- --></A><H3>
move</H3>
<PRE>
public java.lang.Long <B>move</B>(byte[]&nbsp;key,
                           int&nbsp;dbIndex)</PRE>
<DL>
<DD>Move the specified key from the currently selected DB to the specified
 destination DB. Note that this command returns 1 only if the key was
 successfully moved, and 0 if the target key was already there or if the
 source key was not found at all, so it is possible to use MOVE as a
 locking primitive.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>dbIndex</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the key was moved 0 if the key
         was not moved because already present on the target DB or was not
         found in the current DB.</DL>
</DD>
</DL>
<HR>

<A NAME="flushAll()"><!-- --></A><H3>
flushAll</H3>
<PRE>
public java.lang.String <B>flushAll</B>()</PRE>
<DL>
<DD>Delete all the keys of all the existing databases, not just the currently
 selected one. This command never fails.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="getSet(byte[], byte[])"><!-- --></A><H3>
getSet</H3>
<PRE>
public byte[] <B>getSet</B>(byte[]&nbsp;key,
                     byte[]&nbsp;value)</PRE>
<DL>
<DD>GETSET is an atomic set this value and return the old value command. Set
 key to the string value and return the old value stored at key. The
 string can't be longer than 1073741824 bytes (1 GB).
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#getSet(byte[], byte[])">getSet</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="mget(byte[]...)"><!-- --></A><H3>
mget</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>mget</B>(byte[]...&nbsp;keys)</PRE>
<DL>
<DD>Get the values of all the specified keys. If one or more keys dont exist
 or is not of type String, a 'nil' value is returned instead of the value
 of the specified key, but the operation never fails.
 <p>
 Time complexity: O(1) for every key
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="setnx(byte[], byte[])"><!-- --></A><H3>
setnx</H3>
<PRE>
public java.lang.Long <B>setnx</B>(byte[]&nbsp;key,
                            byte[]&nbsp;value)</PRE>
<DL>
<DD>SETNX works exactly like <CODE>SET</CODE> with the only
 difference that if the key already exists no operation is performed.
 SETNX actually means "SET if Not eXists".
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#setnx(byte[], byte[])">setnx</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the key was set 0 if the key
         was not set</DL>
</DD>
</DL>
<HR>

<A NAME="setex(byte[], int, byte[])"><!-- --></A><H3>
setex</H3>
<PRE>
public java.lang.String <B>setex</B>(byte[]&nbsp;key,
                              int&nbsp;seconds,
                              byte[]&nbsp;value)</PRE>
<DL>
<DD>The command is exactly equivalent to the following group of commands:
 <CODE>SET</CODE> + <CODE>EXPIRE</CODE>.
 The operation is atomic.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#setex(byte[], int, byte[])">setex</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>seconds</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="mset(byte[]...)"><!-- --></A><H3>
mset</H3>
<PRE>
public java.lang.String <B>mset</B>(byte[]...&nbsp;keysvalues)</PRE>
<DL>
<DD>Set the the respective keys to the respective values. MSET will replace
 old values with new values, while <CODE>MSETNX</CODE> will
 not perform any operation at all even if just a single key already
 exists.
 <p>
 Because of this semantic MSETNX can be used in order to set different
 keys representing different fields of an unique logic object in a way
 that ensures that either all the fields or none at all are set.
 <p>
 Both MSET and MSETNX are atomic operations. This means that for instance
 if the keys A and B are modified, another client talking to Redis can
 either see the changes to both A and B at once, or no modification at
 all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keysvalues</CODE> - 
<DT><B>Returns:</B><DD>Status code reply Basically +OK as MSET can't fail<DT><B>See Also:</B><DD><CODE>#msetnx(String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="msetnx(byte[]...)"><!-- --></A><H3>
msetnx</H3>
<PRE>
public java.lang.Long <B>msetnx</B>(byte[]...&nbsp;keysvalues)</PRE>
<DL>
<DD>Set the the respective keys to the respective values.
 <CODE>MSET</CODE> will replace old values with new values,
 while MSETNX will not perform any operation at all even if just a single
 key already exists.
 <p>
 Because of this semantic MSETNX can be used in order to set different
 keys representing different fields of an unique logic object in a way
 that ensures that either all the fields or none at all are set.
 <p>
 Both MSET and MSETNX are atomic operations. This means that for instance
 if the keys A and B are modified, another client talking to Redis can
 either see the changes to both A and B at once, or no modification at
 all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keysvalues</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the all the keys were set 0 if
         no key was set (at least one key already existed)<DT><B>See Also:</B><DD><CODE>#mset(String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="decrBy(byte[], long)"><!-- --></A><H3>
decrBy</H3>
<PRE>
public java.lang.Long <B>decrBy</B>(byte[]&nbsp;key,
                             long&nbsp;integer)</PRE>
<DL>
<DD>IDECRBY work just like <CODE>INCR</CODE> but instead to
 decrement by 1 the decrement is integer.
 <p>
 INCR commands are limited to 64 bit signed integers.
 <p>
 Note: this is actually a string operation, that is, in Redis there are
 not "integer" types. Simply the string stored at the key is parsed as a
 base 10 64 bit signed integer, incremented, and then converted back as a
 string.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#decrBy(byte[], long)">decrBy</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>integer</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, this commands will reply with the new value of key
         after the increment.<DT><B>See Also:</B><DD><CODE>#incr(String)</CODE>, 
<CODE>#decr(String)</CODE>, 
<CODE>#incrBy(String, int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="decr(byte[])"><!-- --></A><H3>
decr</H3>
<PRE>
public java.lang.Long <B>decr</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Decrement the number stored at key by one. If the key does not exist or
 contains a value of a wrong type, set the key to the value of "0" before
 to perform the decrement operation.
 <p>
 INCR commands are limited to 64 bit signed integers.
 <p>
 Note: this is actually a string operation, that is, in Redis there are
 not "integer" types. Simply the string stored at the key is parsed as a
 base 10 64 bit signed integer, incremented, and then converted back as a
 string.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#decr(byte[])">decr</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, this commands will reply with the new value of key
         after the increment.<DT><B>See Also:</B><DD><CODE>#incr(String)</CODE>, 
<CODE>#incrBy(String, int)</CODE>, 
<CODE>#decrBy(String, int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="incrBy(byte[], long)"><!-- --></A><H3>
incrBy</H3>
<PRE>
public java.lang.Long <B>incrBy</B>(byte[]&nbsp;key,
                             long&nbsp;integer)</PRE>
<DL>
<DD>INCRBY work just like <CODE>INCR</CODE> but instead to increment
 by 1 the increment is integer.
 <p>
 INCR commands are limited to 64 bit signed integers.
 <p>
 Note: this is actually a string operation, that is, in Redis there are
 not "integer" types. Simply the string stored at the key is parsed as a
 base 10 64 bit signed integer, incremented, and then converted back as a
 string.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#incrBy(byte[], long)">incrBy</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>integer</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, this commands will reply with the new value of key
         after the increment.<DT><B>See Also:</B><DD><CODE>#incr(String)</CODE>, 
<CODE>#decr(String)</CODE>, 
<CODE>#decrBy(String, int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="incr(byte[])"><!-- --></A><H3>
incr</H3>
<PRE>
public java.lang.Long <B>incr</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Increment the number stored at key by one. If the key does not exist or
 contains a value of a wrong type, set the key to the value of "0" before
 to perform the increment operation.
 <p>
 INCR commands are limited to 64 bit signed integers.
 <p>
 Note: this is actually a string operation, that is, in Redis there are
 not "integer" types. Simply the string stored at the key is parsed as a
 base 10 64 bit signed integer, incremented, and then converted back as a
 string.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#incr(byte[])">incr</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, this commands will reply with the new value of key
         after the increment.<DT><B>See Also:</B><DD><CODE>#incrBy(String, int)</CODE>, 
<CODE>#decr(String)</CODE>, 
<CODE>#decrBy(String, int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="append(byte[], byte[])"><!-- --></A><H3>
append</H3>
<PRE>
public java.lang.Long <B>append</B>(byte[]&nbsp;key,
                             byte[]&nbsp;value)</PRE>
<DL>
<DD>If the key already exists and is a string, this command appends the
 provided value at the end of the string. If the key does not exist it is
 created and set as an empty string, so APPEND will be very similar to SET
 in this special case.
 <p>
 Time complexity: O(1). The amortized time complexity is O(1) assuming the
 appended value is small and the already present value is of any size,
 since the dynamic string library used by Redis will double the free space
 available on every reallocation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#append(byte[], byte[])">append</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically the total length of the string after
         the append operation.</DL>
</DD>
</DL>
<HR>

<A NAME="substr(byte[], int, int)"><!-- --></A><H3>
substr</H3>
<PRE>
public byte[] <B>substr</B>(byte[]&nbsp;key,
                     int&nbsp;start,
                     int&nbsp;end)</PRE>
<DL>
<DD>Return a subset of the string from offset start to offset end (both
 offsets are inclusive). Negative offsets can be used in order to provide
 an offset starting from the end of the string. So -1 means the last char,
 -2 the penultimate and so forth.
 <p>
 The function handles out of range requests without raising an error, but
 just limiting the resulting range to the actual length of the string.
 <p>
 Time complexity: O(start+n) (with start being the start index and n the
 total length of the requested range). Note that the lookup part of this
 command is O(1) so for small strings this is actually an O(1) command.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#substr(byte[], int, int)">substr</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>start</CODE> - <DD><CODE>end</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="hset(byte[], byte[], byte[])"><!-- --></A><H3>
hset</H3>
<PRE>
public java.lang.Long <B>hset</B>(byte[]&nbsp;key,
                           byte[]&nbsp;field,
                           byte[]&nbsp;value)</PRE>
<DL>
<DD>Set the specified hash field to the specified value.
 <p>
 If key does not exist, a new key holding a hash is created.
 <p>
 <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hset(byte[], byte[], byte[])">hset</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>field</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>If the field already exists, and the HSET just produced an update
         of the value, 0 is returned, otherwise if a new field is created
         1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="hget(byte[], byte[])"><!-- --></A><H3>
hget</H3>
<PRE>
public byte[] <B>hget</B>(byte[]&nbsp;key,
                   byte[]&nbsp;field)</PRE>
<DL>
<DD>If key holds a hash, retrieve the value associated to the specified
 field.
 <p>
 If the field is not found or the key does not exist, a special 'nil'
 value is returned.
 <p>
 <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hget(byte[], byte[])">hget</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>field</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="hsetnx(byte[], byte[], byte[])"><!-- --></A><H3>
hsetnx</H3>
<PRE>
public java.lang.Long <B>hsetnx</B>(byte[]&nbsp;key,
                             byte[]&nbsp;field,
                             byte[]&nbsp;value)</PRE>
<DL>
<DD>Set the specified hash field to the specified value if the field not
 exists. <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hsetnx(byte[], byte[], byte[])">hsetnx</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>field</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>If the field already exists, 0 is returned, otherwise if a new
         field is created 1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="hmset(byte[], java.util.Map)"><!-- --></A><H3>
hmset</H3>
<PRE>
public java.lang.String <B>hmset</B>(byte[]&nbsp;key,
                              java.util.Map&lt;byte[],byte[]&gt;&nbsp;hash)</PRE>
<DL>
<DD>Set the respective fields to the respective values. HMSET replaces old
 values with new values.
 <p>
 If key does not exist, a new key holding a hash is created.
 <p>
 <b>Time complexity:</b> O(N) (with N being the number of fields)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hmset(byte[], java.util.Map)">hmset</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>hash</CODE> - 
<DT><B>Returns:</B><DD>Always OK because HMSET can't fail</DL>
</DD>
</DL>
<HR>

<A NAME="hmget(byte[], byte[]...)"><!-- --></A><H3>
hmget</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>hmget</B>(byte[]&nbsp;key,
                                    byte[]...&nbsp;fields)</PRE>
<DL>
<DD>Retrieve the values associated to the specified fields.
 <p>
 If some of the specified fields do not exist, nil values are returned.
 Non existing keys are considered like empty hashes.
 <p>
 <b>Time complexity:</b> O(N) (with N being the number of fields)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hmget(byte[], byte[]...)">hmget</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>fields</CODE> - 
<DT><B>Returns:</B><DD>Multi Bulk Reply specifically a list of all the values associated
         with the specified fields, in the same order of the request.</DL>
</DD>
</DL>
<HR>

<A NAME="hincrBy(byte[], byte[], long)"><!-- --></A><H3>
hincrBy</H3>
<PRE>
public java.lang.Long <B>hincrBy</B>(byte[]&nbsp;key,
                              byte[]&nbsp;field,
                              long&nbsp;value)</PRE>
<DL>
<DD>Increment the number stored at field in the hash at key by value. If key
 does not exist, a new key holding a hash is created. If field does not
 exist or holds a string, the value is set to 0 before applying the
 operation. Since the value argument is signed you can use this command to
 perform both increments and decrements.
 <p>
 The range of values supported by HINCRBY is limited to 64 bit signed
 integers.
 <p>
 <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hincrBy(byte[], byte[], long)">hincrBy</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>field</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Integer reply The new value at field after the increment
         operation.</DL>
</DD>
</DL>
<HR>

<A NAME="hexists(byte[], byte[])"><!-- --></A><H3>
hexists</H3>
<PRE>
public java.lang.Boolean <B>hexists</B>(byte[]&nbsp;key,
                                 byte[]&nbsp;field)</PRE>
<DL>
<DD>Test for existence of a specified field in a hash.
 
 <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hexists(byte[], byte[])">hexists</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>field</CODE> - 
<DT><B>Returns:</B><DD>Return 1 if the hash stored at key contains the specified field.
         Return 0 if the key is not found or the field is not present.</DL>
</DD>
</DL>
<HR>

<A NAME="hdel(byte[], byte[])"><!-- --></A><H3>
hdel</H3>
<PRE>
public java.lang.Long <B>hdel</B>(byte[]&nbsp;key,
                           byte[]&nbsp;field)</PRE>
<DL>
<DD>Remove the specified field from an hash stored at key.
 <p>
 <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hdel(byte[], byte[])">hdel</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>field</CODE> - 
<DT><B>Returns:</B><DD>If the field was present in the hash it is deleted and 1 is
         returned, otherwise 0 is returned and no operation is performed.</DL>
</DD>
</DL>
<HR>

<A NAME="hlen(byte[])"><!-- --></A><H3>
hlen</H3>
<PRE>
public java.lang.Long <B>hlen</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return the number of items in a hash.
 <p>
 <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hlen(byte[])">hlen</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>The number of entries (fields) contained in the hash stored at
         key. If the specified key does not exist, 0 is returned assuming
         an empty hash.</DL>
</DD>
</DL>
<HR>

<A NAME="hkeys(byte[])"><!-- --></A><H3>
hkeys</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>hkeys</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return all the fields in a hash.
 <p>
 <b>Time complexity:</b> O(N), where N is the total number of entries
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hkeys(byte[])">hkeys</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>All the fields names contained into a hash.</DL>
</DD>
</DL>
<HR>

<A NAME="hvals(byte[])"><!-- --></A><H3>
hvals</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>hvals</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return all the values in a hash.
 <p>
 <b>Time complexity:</b> O(N), where N is the total number of entries
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hvals(byte[])">hvals</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>All the fields values contained into a hash.</DL>
</DD>
</DL>
<HR>

<A NAME="hgetAll(byte[])"><!-- --></A><H3>
hgetAll</H3>
<PRE>
public java.util.Map&lt;byte[],byte[]&gt; <B>hgetAll</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return all the fields and associated values in a hash.
 <p>
 <b>Time complexity:</b> O(N), where N is the total number of entries
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#hgetAll(byte[])">hgetAll</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>All the fields and values contained into a hash.</DL>
</DD>
</DL>
<HR>

<A NAME="rpush(byte[], byte[])"><!-- --></A><H3>
rpush</H3>
<PRE>
public java.lang.Long <B>rpush</B>(byte[]&nbsp;key,
                            byte[]&nbsp;string)</PRE>
<DL>
<DD>Add the string value to the head (LPUSH) or tail (RPUSH) of the list
 stored at key. If the key does not exist an empty list is created just
 before the append operation. If the key exists but is not a List an error
 is returned.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#rpush(byte[], byte[])">rpush</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>string</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically, the number of elements inside the
         list after the push operation.<DT><B>See Also:</B><DD><CODE>BinaryJedis#lpush(String, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="lpush(byte[], byte[])"><!-- --></A><H3>
lpush</H3>
<PRE>
public java.lang.Long <B>lpush</B>(byte[]&nbsp;key,
                            byte[]&nbsp;string)</PRE>
<DL>
<DD>Add the string value to the head (LPUSH) or tail (RPUSH) of the list
 stored at key. If the key does not exist an empty list is created just
 before the append operation. If the key exists but is not a List an error
 is returned.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#lpush(byte[], byte[])">lpush</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>string</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically, the number of elements inside the
         list after the push operation.<DT><B>See Also:</B><DD><CODE>BinaryJedis#rpush(String, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="llen(byte[])"><!-- --></A><H3>
llen</H3>
<PRE>
public java.lang.Long <B>llen</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return the length of the list stored at the specified key. If the key
 does not exist zero is returned (the same behaviour as for empty lists).
 If the value stored at key is not a list an error is returned.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#llen(byte[])">llen</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>The length of the list.</DL>
</DD>
</DL>
<HR>

<A NAME="lrange(byte[], int, int)"><!-- --></A><H3>
lrange</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>lrange</B>(byte[]&nbsp;key,
                                     int&nbsp;start,
                                     int&nbsp;end)</PRE>
<DL>
<DD>Return the specified elements of the list stored at the specified key.
 Start and end are zero-based indexes. 0 is the first element of the list
 (the list head), 1 the next element and so on.
 <p>
 For example LRANGE foobar 0 2 will return the first three elements of the
 list.
 <p>
 start and end can also be negative numbers indicating offsets from the
 end of the list. For example -1 is the last element of the list, -2 the
 penultimate element and so on.
 <p>
 <b>Consistency with range functions in various programming languages</b>
 <p>
 Note that if you have a list of numbers from 0 to 100, LRANGE 0 10 will
 return 11 elements, that is, rightmost item is included. This may or may
 not be consistent with behavior of range-related functions in your
 programming language of choice (think Ruby's Range.new, Array#slice or
 Python's range() function).
 <p>
 LRANGE behavior is consistent with one of Tcl.
 <p>
 <b>Out-of-range indexes</b>
 <p>
 Indexes out of range will not produce an error: if start is over the end
 of the list, or start > end, an empty list is returned. If end is over
 the end of the list Redis will threat it just like the last element of
 the list.
 <p>
 Time complexity: O(start+n) (with n being the length of the range and
 start being the start offset)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#lrange(byte[], int, int)">lrange</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>start</CODE> - <DD><CODE>end</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply, specifically a list of elements in the
         specified range.</DL>
</DD>
</DL>
<HR>

<A NAME="ltrim(byte[], int, int)"><!-- --></A><H3>
ltrim</H3>
<PRE>
public java.lang.String <B>ltrim</B>(byte[]&nbsp;key,
                              int&nbsp;start,
                              int&nbsp;end)</PRE>
<DL>
<DD>Trim an existing list so that it will contain only the specified range of
 elements specified. Start and end are zero-based indexes. 0 is the first
 element of the list (the list head), 1 the next element and so on.
 <p>
 For example LTRIM foobar 0 2 will modify the list stored at foobar key so
 that only the first three elements of the list will remain.
 <p>
 start and end can also be negative numbers indicating offsets from the
 end of the list. For example -1 is the last element of the list, -2 the
 penultimate element and so on.
 <p>
 Indexes out of range will not produce an error: if start is over the end
 of the list, or start > end, an empty list is left as value. If end over
 the end of the list Redis will threat it just like the last element of
 the list.
 <p>
 Hint: the obvious use of LTRIM is together with LPUSH/RPUSH. For example:
 <p>
 <code>lpush("mylist", "someelement"); ltrim("mylist", 0, 99); * </code>
 <p>
 The above two commands will push elements in the list taking care that
 the list will not grow without limits. This is very useful when using
 Redis to store logs for example. It is important to note that when used
 in this way LTRIM is an O(1) operation because in the average case just
 one element is removed from the tail of the list.
 <p>
 Time complexity: O(n) (with n being len of list - len of range)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#ltrim(byte[], int, int)">ltrim</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>start</CODE> - <DD><CODE>end</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="lindex(byte[], int)"><!-- --></A><H3>
lindex</H3>
<PRE>
public byte[] <B>lindex</B>(byte[]&nbsp;key,
                     int&nbsp;index)</PRE>
<DL>
<DD>Return the specified element of the list stored at the specified key. 0
 is the first element, 1 the second and so on. Negative indexes are
 supported, for example -1 is the last element, -2 the penultimate and so
 on.
 <p>
 If the value stored at key is not of list type an error is returned. If
 the index is out of range a 'nil' reply is returned.
 <p>
 Note that even if the average time complexity is O(n) asking for the
 first or the last element of the list is O(1).
 <p>
 Time complexity: O(n) (with n being the length of the list)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#lindex(byte[], int)">lindex</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>index</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply, specifically the requested element</DL>
</DD>
</DL>
<HR>

<A NAME="lset(byte[], int, byte[])"><!-- --></A><H3>
lset</H3>
<PRE>
public java.lang.String <B>lset</B>(byte[]&nbsp;key,
                             int&nbsp;index,
                             byte[]&nbsp;value)</PRE>
<DL>
<DD>Set a new value as the element at index position of the List at key.
 <p>
 Out of range indexes will generate an error.
 <p>
 Similarly to other list commands accepting indexes, the index can be
 negative to access elements starting from the end of the list. So -1 is
 the last element, -2 is the penultimate, and so forth.
 <p>
 <b>Time complexity:</b>
 <p>
 O(N) (with N being the length of the list), setting the first or last
 elements of the list is O(1).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#lset(byte[], int, byte[])">lset</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>index</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Status code reply<DT><B>See Also:</B><DD><CODE>#lindex(String, int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="lrem(byte[], int, byte[])"><!-- --></A><H3>
lrem</H3>
<PRE>
public java.lang.Long <B>lrem</B>(byte[]&nbsp;key,
                           int&nbsp;count,
                           byte[]&nbsp;value)</PRE>
<DL>
<DD>Remove the first count occurrences of the value element from the list. If
 count is zero all the elements are removed. If count is negative elements
 are removed from tail to head, instead to go from head to tail that is
 the normal behaviour. So for example LREM with count -2 and hello as
 value to remove against the list (a,b,c,hello,x,hello,hello) will lave
 the list (a,b,c,hello,x). The number of removed elements is returned as
 an integer, see below for more information about the returned value. Note
 that non existing keys are considered like empty lists by LREM, so LREM
 against non existing keys will always return 0.
 <p>
 Time complexity: O(N) (with N being the length of the list)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#lrem(byte[], int, byte[])">lrem</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>count</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Integer Reply, specifically: The number of removed elements if
         the operation succeeded</DL>
</DD>
</DL>
<HR>

<A NAME="lpop(byte[])"><!-- --></A><H3>
lpop</H3>
<PRE>
public byte[] <B>lpop</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Atomically return and remove the first (LPOP) or last (RPOP) element of
 the list. For example if the list contains the elements "a","b","c" LPOP
 will return "a" and the list will become "b","c".
 <p>
 If the key does not exist or the list is already empty the special value
 'nil' is returned.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#lpop(byte[])">lpop</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply<DT><B>See Also:</B><DD><CODE>#rpop(String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="rpop(byte[])"><!-- --></A><H3>
rpop</H3>
<PRE>
public byte[] <B>rpop</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Atomically return and remove the first (LPOP) or last (RPOP) element of
 the list. For example if the list contains the elements "a","b","c" LPOP
 will return "a" and the list will become "b","c".
 <p>
 If the key does not exist or the list is already empty the special value
 'nil' is returned.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#rpop(byte[])">rpop</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply<DT><B>See Also:</B><DD><CODE>#lpop(String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="rpoplpush(byte[], byte[])"><!-- --></A><H3>
rpoplpush</H3>
<PRE>
public byte[] <B>rpoplpush</B>(byte[]&nbsp;srckey,
                        byte[]&nbsp;dstkey)</PRE>
<DL>
<DD>Atomically return and remove the last (tail) element of the srckey list,
 and push the element as the first (head) element of the dstkey list. For
 example if the source list contains the elements "a","b","c" and the
 destination list contains the elements "foo","bar" after an RPOPLPUSH
 command the content of the two lists will be "a","b" and "c","foo","bar".
 <p>
 If the key does not exist or the list is already empty the special value
 'nil' is returned. If the srckey and dstkey are the same the operation is
 equivalent to removing the last element from the list and pusing it as
 first element of the list, so it's a "list rotation" command.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srckey</CODE> - <DD><CODE>dstkey</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="sadd(byte[], byte[])"><!-- --></A><H3>
sadd</H3>
<PRE>
public java.lang.Long <B>sadd</B>(byte[]&nbsp;key,
                           byte[]&nbsp;member)</PRE>
<DL>
<DD>Add the specified member to the set value stored at key. If member is
 already a member of the set no operation is performed. If key does not
 exist a new set with the specified member as sole member is created. If
 the key exists but does not hold a set value an error is returned.
 <p>
 Time complexity O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#sadd(byte[], byte[])">sadd</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the new element was added 0 if
         the element was already a member of the set</DL>
</DD>
</DL>
<HR>

<A NAME="smembers(byte[])"><!-- --></A><H3>
smembers</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>smembers</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return all the members (elements) of the set value stored at key. This is
 just syntax glue for <CODE>SINTER</CODE>.
 <p>
 Time complexity O(N)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#smembers(byte[])">smembers</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="srem(byte[], byte[])"><!-- --></A><H3>
srem</H3>
<PRE>
public java.lang.Long <B>srem</B>(byte[]&nbsp;key,
                           byte[]&nbsp;member)</PRE>
<DL>
<DD>Remove the specified member from the set value stored at key. If member
 was not a member of the set no operation is performed. If key does not
 hold a set value an error is returned.
 <p>
 Time complexity O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#srem(byte[], byte[])">srem</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the new element was removed 0
         if the new element was not a member of the set</DL>
</DD>
</DL>
<HR>

<A NAME="spop(byte[])"><!-- --></A><H3>
spop</H3>
<PRE>
public byte[] <B>spop</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Remove a random element from a Set returning it as return value. If the
 Set is empty or the key does not exist, a nil object is returned.
 <p>
 The <CODE>#srandmember(String)</CODE> command does a similar work but the
 returned element is not removed from the Set.
 <p>
 Time complexity O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#spop(byte[])">spop</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="smove(byte[], byte[], byte[])"><!-- --></A><H3>
smove</H3>
<PRE>
public java.lang.Long <B>smove</B>(byte[]&nbsp;srckey,
                            byte[]&nbsp;dstkey,
                            byte[]&nbsp;member)</PRE>
<DL>
<DD>Move the specifided member from the set at srckey to the set at dstkey.
 This operation is atomic, in every given moment the element will appear
 to be in the source or destination set for accessing clients.
 <p>
 If the source set does not exist or does not contain the specified
 element no operation is performed and zero is returned, otherwise the
 element is removed from the source set and added to the destination set.
 On success one is returned, even if the element was already present in
 the destination set.
 <p>
 An error is raised if the source or destination keys contain a non Set
 value.
 <p>
 Time complexity O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srckey</CODE> - <DD><CODE>dstkey</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the element was moved 0 if the
         element was not found on the first set and no operation was
         performed</DL>
</DD>
</DL>
<HR>

<A NAME="scard(byte[])"><!-- --></A><H3>
scard</H3>
<PRE>
public java.lang.Long <B>scard</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return the set cardinality (number of elements). If the key does not
 exist 0 is returned, like for empty sets.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#scard(byte[])">scard</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: the cardinality (number of elements)
         of the set as an integer.</DL>
</DD>
</DL>
<HR>

<A NAME="sismember(byte[], byte[])"><!-- --></A><H3>
sismember</H3>
<PRE>
public java.lang.Boolean <B>sismember</B>(byte[]&nbsp;key,
                                   byte[]&nbsp;member)</PRE>
<DL>
<DD>Return 1 if member is a member of the set stored at key, otherwise 0 is
 returned.
 <p>
 Time complexity O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#sismember(byte[], byte[])">sismember</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the element is a member of the
         set 0 if the element is not a member of the set OR if the key
         does not exist</DL>
</DD>
</DL>
<HR>

<A NAME="sinter(byte[]...)"><!-- --></A><H3>
sinter</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>sinter</B>(byte[]...&nbsp;keys)</PRE>
<DL>
<DD>Return the members of a set resulting from the intersection of all the
 sets hold at the specified keys. Like in
 <CODE>LRANGE</CODE> the result is sent to the client
 as a multi-bulk reply (see the protocol specification for more
 information). If just a single key is specified, then this command
 produces the same result as <CODE>SMEMBERS</CODE>. Actually
 SMEMBERS is just syntax sugar for SINTER.
 <p>
 Non existing keys are considered like empty sets, so if one of the keys
 is missing an empty set is returned (since the intersection with an empty
 set always is an empty set).
 <p>
 Time complexity O(N*M) worst case where N is the cardinality of the
 smallest set and M the number of sets
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply, specifically the list of common elements.</DL>
</DD>
</DL>
<HR>

<A NAME="sinterstore(byte[], byte[]...)"><!-- --></A><H3>
sinterstore</H3>
<PRE>
public java.lang.Long <B>sinterstore</B>(byte[]&nbsp;dstkey,
                                  byte[]...&nbsp;keys)</PRE>
<DL>
<DD>This commnad works exactly like <CODE>SINTER</CODE> but
 instead of being returned the resulting set is sotred as dstkey.
 <p>
 Time complexity O(N*M) worst case where N is the cardinality of the
 smallest set and M the number of sets
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstkey</CODE> - <DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="sunion(byte[]...)"><!-- --></A><H3>
sunion</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>sunion</B>(byte[]...&nbsp;keys)</PRE>
<DL>
<DD>Return the members of a set resulting from the union of all the sets hold
 at the specified keys. Like in <CODE>LRANGE</CODE>
 the result is sent to the client as a multi-bulk reply (see the protocol
 specification for more information). If just a single key is specified,
 then this command produces the same result as <CODE>SMEMBERS</CODE>.
 <p>
 Non existing keys are considered like empty sets.
 <p>
 Time complexity O(N) where N is the total number of elements in all the
 provided sets
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply, specifically the list of common elements.</DL>
</DD>
</DL>
<HR>

<A NAME="sunionstore(byte[], byte[]...)"><!-- --></A><H3>
sunionstore</H3>
<PRE>
public java.lang.Long <B>sunionstore</B>(byte[]&nbsp;dstkey,
                                  byte[]...&nbsp;keys)</PRE>
<DL>
<DD>This command works exactly like <CODE>SUNION</CODE> but
 instead of being returned the resulting set is stored as dstkey. Any
 existing value in dstkey will be over-written.
 <p>
 Time complexity O(N) where N is the total number of elements in all the
 provided sets
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstkey</CODE> - <DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="sdiff(byte[]...)"><!-- --></A><H3>
sdiff</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>sdiff</B>(byte[]...&nbsp;keys)</PRE>
<DL>
<DD>Return the difference between the Set stored at key1 and all the Sets
 key2, ..., keyN
 <p>
 <b>Example:</b>
 
 <pre>
 key1 = [x, a, b, c]
 key2 = [c]
 key3 = [a, d]
 SDIFF key1,key2,key3 => [x, b]
 </pre>
 
 Non existing keys are considered like empty sets.
 <p>
 <b>Time complexity:</b>
 <p>
 O(N) with N being the total number of elements of all the sets
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Return the members of a set resulting from the difference between
         the first set provided and all the successive sets.</DL>
</DD>
</DL>
<HR>

<A NAME="sdiffstore(byte[], byte[]...)"><!-- --></A><H3>
sdiffstore</H3>
<PRE>
public java.lang.Long <B>sdiffstore</B>(byte[]&nbsp;dstkey,
                                 byte[]...&nbsp;keys)</PRE>
<DL>
<DD>This command works exactly like <CODE>SDIFF</CODE> but
 instead of being returned the resulting set is stored in dstkey.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstkey</CODE> - <DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="srandmember(byte[])"><!-- --></A><H3>
srandmember</H3>
<PRE>
public byte[] <B>srandmember</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return a random element from a Set, without removing the element. If the
 Set is empty or the key does not exist, a nil object is returned.
 <p>
 The SPOP command does a similar work but the returned element is popped
 (removed) from the Set.
 <p>
 Time complexity O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#srandmember(byte[])">srandmember</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="zadd(byte[], double, byte[])"><!-- --></A><H3>
zadd</H3>
<PRE>
public java.lang.Long <B>zadd</B>(byte[]&nbsp;key,
                           double&nbsp;score,
                           byte[]&nbsp;member)</PRE>
<DL>
<DD>Add the specified member having the specifeid score to the sorted set
 stored at key. If member is already a member of the sorted set the score
 is updated, and the element reinserted in the right position to ensure
 sorting. If key does not exist a new sorted set with the specified member
 as sole member is crated. If the key exists but does not hold a sorted
 set value an error is returned.
 <p>
 The score value can be the string representation of a double precision
 floating point number.
 <p>
 Time complexity O(log(N)) with N being the number of elements in the
 sorted set
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zadd(byte[], double, byte[])">zadd</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>score</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the new element was added 0 if
         the element was already a member of the sorted set and the score
         was updated</DL>
</DD>
</DL>
<HR>

<A NAME="zrange(byte[], int, int)"><!-- --></A><H3>
zrange</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrange</B>(byte[]&nbsp;key,
                                    int&nbsp;start,
                                    int&nbsp;end)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrange(byte[], int, int)">zrange</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrem(byte[], byte[])"><!-- --></A><H3>
zrem</H3>
<PRE>
public java.lang.Long <B>zrem</B>(byte[]&nbsp;key,
                           byte[]&nbsp;member)</PRE>
<DL>
<DD>Remove the specified member from the sorted set value stored at key. If
 member was not a member of the set no operation is performed. If key does
 not not hold a set value an error is returned.
 <p>
 Time complexity O(log(N)) with N being the number of elements in the
 sorted set
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrem(byte[], byte[])">zrem</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1 if the new element was removed 0
         if the new element was not a member of the set</DL>
</DD>
</DL>
<HR>

<A NAME="zincrby(byte[], double, byte[])"><!-- --></A><H3>
zincrby</H3>
<PRE>
public java.lang.Double <B>zincrby</B>(byte[]&nbsp;key,
                                double&nbsp;score,
                                byte[]&nbsp;member)</PRE>
<DL>
<DD>If member already exists in the sorted set adds the increment to its
 score and updates the position of the element in the sorted set
 accordingly. If member does not already exist in the sorted set it is
 added with increment as score (that is, like if the previous score was
 virtually zero). If key does not exist a new sorted set with the
 specified member as sole member is crated. If the key exists but does not
 hold a sorted set value an error is returned.
 <p>
 The score value can be the string representation of a double precision
 floating point number. It's possible to provide a negative value to
 perform a decrement.
 <p>
 For an introduction to sorted sets check the Introduction to Redis data
 types page.
 <p>
 Time complexity O(log(N)) with N being the number of elements in the
 sorted set
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zincrby(byte[], double, byte[])">zincrby</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>score</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>The new score</DL>
</DD>
</DL>
<HR>

<A NAME="zrank(byte[], byte[])"><!-- --></A><H3>
zrank</H3>
<PRE>
public java.lang.Long <B>zrank</B>(byte[]&nbsp;key,
                            byte[]&nbsp;member)</PRE>
<DL>
<DD>Return the rank (or index) or member in the sorted set at key, with
 scores being ordered from low to high.
 <p>
 When the given member does not exist in the sorted set, the special value
 'nil' is returned. The returned rank (or index) of the member is 0-based
 for both commands.
 <p>
 <b>Time complexity:</b>
 <p>
 O(log(N))
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrank(byte[], byte[])">zrank</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply or a nil bulk reply, specifically: the rank of the
         element as an integer reply if the element exists. A nil bulk
         reply if there is no such element.<DT><B>See Also:</B><DD><CODE>#zrevrank(String, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zrevrank(byte[], byte[])"><!-- --></A><H3>
zrevrank</H3>
<PRE>
public java.lang.Long <B>zrevrank</B>(byte[]&nbsp;key,
                               byte[]&nbsp;member)</PRE>
<DL>
<DD>Return the rank (or index) or member in the sorted set at key, with
 scores being ordered from high to low.
 <p>
 When the given member does not exist in the sorted set, the special value
 'nil' is returned. The returned rank (or index) of the member is 0-based
 for both commands.
 <p>
 <b>Time complexity:</b>
 <p>
 O(log(N))
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrevrank(byte[], byte[])">zrevrank</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>Integer reply or a nil bulk reply, specifically: the rank of the
         element as an integer reply if the element exists. A nil bulk
         reply if there is no such element.<DT><B>See Also:</B><DD><CODE>#zrank(String, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zrevrange(byte[], int, int)"><!-- --></A><H3>
zrevrange</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrevrange</B>(byte[]&nbsp;key,
                                       int&nbsp;start,
                                       int&nbsp;end)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrevrange(byte[], int, int)">zrevrange</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrangeWithScores(byte[], int, int)"><!-- --></A><H3>
zrangeWithScores</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt; <B>zrangeWithScores</B>(byte[]&nbsp;key,
                                             int&nbsp;start,
                                             int&nbsp;end)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrangeWithScores(byte[], int, int)">zrangeWithScores</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrevrangeWithScores(byte[], int, int)"><!-- --></A><H3>
zrevrangeWithScores</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt; <B>zrevrangeWithScores</B>(byte[]&nbsp;key,
                                                int&nbsp;start,
                                                int&nbsp;end)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrevrangeWithScores(byte[], int, int)">zrevrangeWithScores</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zcard(byte[])"><!-- --></A><H3>
zcard</H3>
<PRE>
public java.lang.Long <B>zcard</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Return the sorted set cardinality (number of elements). If the key does
 not exist 0 is returned, like for empty sorted sets.
 <p>
 Time complexity O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zcard(byte[])">zcard</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>the cardinality (number of elements) of the set as an integer.</DL>
</DD>
</DL>
<HR>

<A NAME="zscore(byte[], byte[])"><!-- --></A><H3>
zscore</H3>
<PRE>
public java.lang.Double <B>zscore</B>(byte[]&nbsp;key,
                               byte[]&nbsp;member)</PRE>
<DL>
<DD>Return the score of the specified element of the sorted set at key. If
 the specified element does not exist in the sorted set, or the key does
 not exist at all, a special 'nil' value is returned.
 <p>
 <b>Time complexity:</b> O(1)
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zscore(byte[], byte[])">zscore</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>member</CODE> - 
<DT><B>Returns:</B><DD>the score</DL>
</DD>
</DL>
<HR>

<A NAME="multi()"><!-- --></A><H3>
multi</H3>
<PRE>
public <A HREF="../../../redis/clients/jedis/Transaction.html" title="class in redis.clients.jedis">Transaction</A> <B>multi</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="multi(redis.clients.jedis.TransactionBlock)"><!-- --></A><H3>
multi</H3>
<PRE>
public java.util.List&lt;java.lang.Object&gt; <B>multi</B>(<A HREF="../../../redis/clients/jedis/TransactionBlock.html" title="class in redis.clients.jedis">TransactionBlock</A>&nbsp;jedisTransaction)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkIsInMulti()"><!-- --></A><H3>
checkIsInMulti</H3>
<PRE>
protected void <B>checkIsInMulti</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="connect()"><!-- --></A><H3>
connect</H3>
<PRE>
public void <B>connect</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="disconnect()"><!-- --></A><H3>
disconnect</H3>
<PRE>
public void <B>disconnect</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="watch(byte[])"><!-- --></A><H3>
watch</H3>
<PRE>
public java.lang.String <B>watch</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="unwatch()"><!-- --></A><H3>
unwatch</H3>
<PRE>
public java.lang.String <B>unwatch</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[])"><!-- --></A><H3>
sort</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>sort</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Sort a Set or a List.
 <p>
 Sort the elements contained in the List, Set, or Sorted Set value at key.
 By default sorting is numeric with elements being compared as double
 precision floating point numbers. This is the simplest form of SORT.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#sort(byte[])">sort</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Assuming the Set/List at key contains a list of numbers, the
         return value will be the list of numbers ordered from the
         smallest to the biggest number.<DT><B>See Also:</B><DD><CODE>#sort(String, String)</CODE>, 
<CODE>#sort(String, SortingParams)</CODE>, 
<CODE>#sort(String, SortingParams, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[], redis.clients.jedis.SortingParams)"><!-- --></A><H3>
sort</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>sort</B>(byte[]&nbsp;key,
                                   <A HREF="../../../redis/clients/jedis/SortingParams.html" title="class in redis.clients.jedis">SortingParams</A>&nbsp;sortingParameters)</PRE>
<DL>
<DD>Sort a Set or a List accordingly to the specified parameters.
 <p>
 <b>examples:</b>
 <p>
 Given are the following sets and key/values:
 
 <pre>
 x = [1, 2, 3]
 y = [a, b, c]
 
 k1 = z
 k2 = y
 k3 = x
 
 w1 = 9
 w2 = 8
 w3 = 7
 </pre>
 
 Sort Order:
 
 <pre>
 sort(x) or sort(x, sp.asc())
 -> [1, 2, 3]
 
 sort(x, sp.desc())
 -> [3, 2, 1]
 
 sort(y)
 -> [c, a, b]
 
 sort(y, sp.alpha())
 -> [a, b, c]
 
 sort(y, sp.alpha().desc())
 -> [c, a, b]
 </pre>
 
 Limit (e.g. for Pagination):
 
 <pre>
 sort(x, sp.limit(0, 2))
 -> [1, 2]
 
 sort(y, sp.alpha().desc().limit(1, 2))
 -> [b, a]
 </pre>
 
 Sorting by external keys:
 
 <pre>
 sort(x, sb.by(w*))
 -> [3, 2, 1]
 
 sort(x, sb.by(w*).desc())
 -> [1, 2, 3]
 </pre>
 
 Getting external keys:
 
 <pre>
 sort(x, sp.by(w*).get(k*))
 -> [x, y, z]
 
 sort(x, sp.by(w*).get(#).get(k*))
 -> [3, x, 2, y, 1, z]
 </pre>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#sort(byte[], redis.clients.jedis.SortingParams)">sort</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>sortingParameters</CODE> - 
<DT><B>Returns:</B><DD>a list of sorted elements.<DT><B>See Also:</B><DD><CODE>#sort(String)</CODE>, 
<CODE>#sort(String, SortingParams, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="blpop(int, byte[]...)"><!-- --></A><H3>
blpop</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>blpop</B>(int&nbsp;timeout,
                                    byte[]...&nbsp;keys)</PRE>
<DL>
<DD>BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
 commands as blocking versions of LPOP and RPOP able to block if the
 specified keys don't exist or contain empty lists.
 <p>
 The following is a description of the exact semantic. We describe BLPOP
 but the two commands are identical, the only difference is that BLPOP
 pops the element from the left (head) of the list, and BRPOP pops from
 the right (tail).
 <p>
 <b>Non blocking behavior</b>
 <p>
 When BLPOP is called, if at least one of the specified keys contain a non
 empty list, an element is popped from the head of the list and returned
 to the caller together with the name of the key (BLPOP returns a two
 elements array, the first element is the key, the second the popped
 value).
 <p>
 Keys are scanned from left to right, so for instance if you issue BLPOP
 list1 list2 list3 0 against a dataset where list1 does not exist but
 list2 and list3 contain non empty lists, BLPOP guarantees to return an
 element from the list stored at list2 (since it is the first non empty
 list starting from the left).
 <p>
 <b>Blocking behavior</b>
 <p>
 If none of the specified keys exist or contain non empty lists, BLPOP
 blocks until some other client performs a LPUSH or an RPUSH operation
 against one of the lists.
 <p>
 Once new data is present on one of the lists, the client finally returns
 with the name of the key unblocking it and the popped value.
 <p>
 When blocking, if a non-zero timeout is specified, the client will
 unblock returning a nil special value if the specified amount of seconds
 passed without a push operation against at least one of the specified
 keys.
 <p>
 The timeout argument is interpreted as an integer value. A timeout of
 zero means instead to block forever.
 <p>
 <b>Multiple clients blocking for the same keys</b>
 <p>
 Multiple clients can block for the same key. They are put into a queue,
 so the first to be served will be the one that started to wait earlier,
 in a first-blpopping first-served fashion.
 <p>
 <b>blocking POP inside a MULTI/EXEC transaction</b>
 <p>
 BLPOP and BRPOP can be used with pipelining (sending multiple commands
 and reading the replies in batch), but it does not make sense to use
 BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
 <p>
 The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
 return a multi-bulk nil reply, exactly what happens when the timeout is
 reached. If you like science fiction, think at it like if inside
 MULTI/EXEC the time will flow at infinite speed :)
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - <DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>BLPOP returns a two-elements array via a multi bulk reply in
         order to return both the unblocking key and the popped value.
         <p>
         When a non-zero timeout is specified, and the BLPOP operation
         timed out, the return value is a nil multi bulk reply. Most
         client values will return false or nil accordingly to the
         programming language used.<DT><B>See Also:</B><DD><CODE>#brpop(int, String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[], redis.clients.jedis.SortingParams, byte[])"><!-- --></A><H3>
sort</H3>
<PRE>
public java.lang.Long <B>sort</B>(byte[]&nbsp;key,
                           <A HREF="../../../redis/clients/jedis/SortingParams.html" title="class in redis.clients.jedis">SortingParams</A>&nbsp;sortingParameters,
                           byte[]&nbsp;dstkey)</PRE>
<DL>
<DD>Sort a Set or a List accordingly to the specified parameters and store
 the result at dstkey.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>sortingParameters</CODE> - <DD><CODE>dstkey</CODE> - 
<DT><B>Returns:</B><DD>The number of elements of the list at dstkey.<DT><B>See Also:</B><DD><CODE>#sort(String, SortingParams)</CODE>, 
<CODE>#sort(String)</CODE>, 
<CODE>#sort(String, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[], byte[])"><!-- --></A><H3>
sort</H3>
<PRE>
public java.lang.Long <B>sort</B>(byte[]&nbsp;key,
                           byte[]&nbsp;dstkey)</PRE>
<DL>
<DD>Sort a Set or a List and Store the Result at dstkey.
 <p>
 Sort the elements contained in the List, Set, or Sorted Set value at key
 and store the result at dstkey. By default sorting is numeric with
 elements being compared as double precision floating point numbers. This
 is the simplest form of SORT.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>dstkey</CODE> - 
<DT><B>Returns:</B><DD>The number of elements of the list at dstkey.<DT><B>See Also:</B><DD><CODE>#sort(String)</CODE>, 
<CODE>#sort(String, SortingParams)</CODE>, 
<CODE>#sort(String, SortingParams, String)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="brpop(int, byte[]...)"><!-- --></A><H3>
brpop</H3>
<PRE>
public java.util.List&lt;byte[]&gt; <B>brpop</B>(int&nbsp;timeout,
                                    byte[]...&nbsp;keys)</PRE>
<DL>
<DD>BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
 commands as blocking versions of LPOP and RPOP able to block if the
 specified keys don't exist or contain empty lists.
 <p>
 The following is a description of the exact semantic. We describe BLPOP
 but the two commands are identical, the only difference is that BLPOP
 pops the element from the left (head) of the list, and BRPOP pops from
 the right (tail).
 <p>
 <b>Non blocking behavior</b>
 <p>
 When BLPOP is called, if at least one of the specified keys contain a non
 empty list, an element is popped from the head of the list and returned
 to the caller together with the name of the key (BLPOP returns a two
 elements array, the first element is the key, the second the popped
 value).
 <p>
 Keys are scanned from left to right, so for instance if you issue BLPOP
 list1 list2 list3 0 against a dataset where list1 does not exist but
 list2 and list3 contain non empty lists, BLPOP guarantees to return an
 element from the list stored at list2 (since it is the first non empty
 list starting from the left).
 <p>
 <b>Blocking behavior</b>
 <p>
 If none of the specified keys exist or contain non empty lists, BLPOP
 blocks until some other client performs a LPUSH or an RPUSH operation
 against one of the lists.
 <p>
 Once new data is present on one of the lists, the client finally returns
 with the name of the key unblocking it and the popped value.
 <p>
 When blocking, if a non-zero timeout is specified, the client will
 unblock returning a nil special value if the specified amount of seconds
 passed without a push operation against at least one of the specified
 keys.
 <p>
 The timeout argument is interpreted as an integer value. A timeout of
 zero means instead to block forever.
 <p>
 <b>Multiple clients blocking for the same keys</b>
 <p>
 Multiple clients can block for the same key. They are put into a queue,
 so the first to be served will be the one that started to wait earlier,
 in a first-blpopping first-served fashion.
 <p>
 <b>blocking POP inside a MULTI/EXEC transaction</b>
 <p>
 BLPOP and BRPOP can be used with pipelining (sending multiple commands
 and reading the replies in batch), but it does not make sense to use
 BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
 <p>
 The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
 return a multi-bulk nil reply, exactly what happens when the timeout is
 reached. If you like science fiction, think at it like if inside
 MULTI/EXEC the time will flow at infinite speed :)
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - <DD><CODE>keys</CODE> - 
<DT><B>Returns:</B><DD>BLPOP returns a two-elements array via a multi bulk reply in
         order to return both the unblocking key and the popped value.
         <p>
         When a non-zero timeout is specified, and the BLPOP operation
         timed out, the return value is a nil multi bulk reply. Most
         client values will return false or nil accordingly to the
         programming language used.<DT><B>See Also:</B><DD><CODE>#blpop(int, String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="auth(java.lang.String)"><!-- --></A><H3>
auth</H3>
<PRE>
public java.lang.String <B>auth</B>(java.lang.String&nbsp;password)</PRE>
<DL>
<DD>Request for authentication in a password protected Redis server. A Redis
 server can be instructed to require a password before to allow clients to
 issue commands. This is done using the requirepass directive in the Redis
 configuration file. If the password given by the client is correct the
 server replies with an OK status code reply and starts accepting commands
 from the client. Otherwise an error is returned and the clients needs to
 try a new password. Note that for the high performance nature of Redis it
 is possible to try a lot of passwords in parallel in very short time, so
 make sure to generate a strong and very long password so that this attack
 is infeasible.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>password</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="pipelined(redis.clients.jedis.PipelineBlock)"><!-- --></A><H3>
pipelined</H3>
<PRE>
public java.util.List&lt;java.lang.Object&gt; <B>pipelined</B>(<A HREF="../../../redis/clients/jedis/PipelineBlock.html" title="class in redis.clients.jedis">PipelineBlock</A>&nbsp;jedisPipeline)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pipelined()"><!-- --></A><H3>
pipelined</H3>
<PRE>
public <A HREF="../../../redis/clients/jedis/Pipeline.html" title="class in redis.clients.jedis">Pipeline</A> <B>pipelined</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(redis.clients.jedis.JedisPubSub, java.lang.String...)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public void <B>subscribe</B>(<A HREF="../../../redis/clients/jedis/JedisPubSub.html" title="class in redis.clients.jedis">JedisPubSub</A>&nbsp;jedisPubSub,
                      java.lang.String...&nbsp;channels)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="publish(java.lang.String, java.lang.String)"><!-- --></A><H3>
publish</H3>
<PRE>
public java.lang.Long <B>publish</B>(java.lang.String&nbsp;channel,
                              java.lang.String&nbsp;message)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="psubscribe(redis.clients.jedis.JedisPubSub, java.lang.String...)"><!-- --></A><H3>
psubscribe</H3>
<PRE>
public void <B>psubscribe</B>(<A HREF="../../../redis/clients/jedis/JedisPubSub.html" title="class in redis.clients.jedis">JedisPubSub</A>&nbsp;jedisPubSub,
                       java.lang.String...&nbsp;patterns)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zcount(byte[], double, double)"><!-- --></A><H3>
zcount</H3>
<PRE>
public java.lang.Long <B>zcount</B>(byte[]&nbsp;key,
                             double&nbsp;min,
                             double&nbsp;max)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zcount(byte[], double, double)">zcount</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrangeByScore(byte[], double, double)"><!-- --></A><H3>
zrangeByScore</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrangeByScore</B>(byte[]&nbsp;key,
                                           double&nbsp;min,
                                           double&nbsp;max)</PRE>
<DL>
<DD>Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).
 <p>
 The elements having the same score are returned sorted lexicographically
 as ASCII strings (this follows from a property of Redis sorted sets and
 does not involve further computation).
 <p>
 Using the optional
 <CODE>LIMIT</CODE> it's
 possible to get only a range of the matching elements in an SQL-alike
 way. Note that if offset is large the commands needs to traverse the list
 for offset elements and this adds up to the O(M) figure.
 <p>
 The <CODE>ZCOUNT</CODE> command is similar to
 <CODE>ZRANGEBYSCORE</CODE> but instead
 of returning the actual elements in the specified interval, it just
 returns the number of matching elements.
 <p>
 <b>Exclusive intervals and infinity</b>
 <p>
 min and max can be -inf and +inf, so that you are not required to know
 what's the greatest or smallest element in order to take, for instance,
 elements "up to a given value".
 <p>
 Also while the interval is for default closed (inclusive) it's possible
 to specify open intervals prefixing the score with a "(" character, so
 for instance:
 <p>
 <code>ZRANGEBYSCORE zset (1.3 5</code>
 <p>
 Will return all the values with score > 1.3 and <= 5, while for instance:
 <p>
 <code>ZRANGEBYSCORE zset (5 (10</code>
 <p>
 Will return all the values with score > 5 and < 10 (5 and 10 excluded).
 <p>
 <b>Time complexity:</b>
 <p>
 O(log(N))+O(M) with N being the number of elements in the sorted set and
 M the number of elements returned by the command, so if M is constant
 (for instance you always ask for the first ten elements with LIMIT) you
 can consider it O(log(N))
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrangeByScore(byte[], double, double)">zrangeByScore</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>min</CODE> - <DD><CODE>max</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply specifically a list of elements in the specified
         score range.<DT><B>See Also:</B><DD><CODE>#zrangeByScore(String, double, double)</CODE>, 
<CODE>#zrangeByScore(String, double, double, int, int)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, String, String)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double, int, int)</CODE>, 
<CODE>#zcount(String, double, double)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zrangeByScore(byte[], byte[], byte[])"><!-- --></A><H3>
zrangeByScore</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrangeByScore</B>(byte[]&nbsp;key,
                                           byte[]&nbsp;min,
                                           byte[]&nbsp;max)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrangeByScore(byte[], double, double, int, int)"><!-- --></A><H3>
zrangeByScore</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrangeByScore</B>(byte[]&nbsp;key,
                                           double&nbsp;min,
                                           double&nbsp;max,
                                           int&nbsp;offset,
                                           int&nbsp;count)</PRE>
<DL>
<DD>Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).
 <p>
 The elements having the same score are returned sorted lexicographically
 as ASCII strings (this follows from a property of Redis sorted sets and
 does not involve further computation).
 <p>
 Using the optional
 <CODE>LIMIT</CODE> it's
 possible to get only a range of the matching elements in an SQL-alike
 way. Note that if offset is large the commands needs to traverse the list
 for offset elements and this adds up to the O(M) figure.
 <p>
 The <CODE>ZCOUNT</CODE> command is similar to
 <CODE>ZRANGEBYSCORE</CODE> but instead
 of returning the actual elements in the specified interval, it just
 returns the number of matching elements.
 <p>
 <b>Exclusive intervals and infinity</b>
 <p>
 min and max can be -inf and +inf, so that you are not required to know
 what's the greatest or smallest element in order to take, for instance,
 elements "up to a given value".
 <p>
 Also while the interval is for default closed (inclusive) it's possible
 to specify open intervals prefixing the score with a "(" character, so
 for instance:
 <p>
 <code>ZRANGEBYSCORE zset (1.3 5</code>
 <p>
 Will return all the values with score > 1.3 and <= 5, while for instance:
 <p>
 <code>ZRANGEBYSCORE zset (5 (10</code>
 <p>
 Will return all the values with score > 5 and < 10 (5 and 10 excluded).
 <p>
 <b>Time complexity:</b>
 <p>
 O(log(N))+O(M) with N being the number of elements in the sorted set and
 M the number of elements returned by the command, so if M is constant
 (for instance you always ask for the first ten elements with LIMIT) you
 can consider it O(log(N))
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrangeByScore(byte[], double, double, int, int)">zrangeByScore</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>min</CODE> - <DD><CODE>max</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply specifically a list of elements in the specified
         score range.<DT><B>See Also:</B><DD><CODE>#zrangeByScore(String, double, double)</CODE>, 
<CODE>#zrangeByScore(String, double, double, int, int)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double, int, int)</CODE>, 
<CODE>#zcount(String, double, double)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zrangeByScoreWithScores(byte[], double, double)"><!-- --></A><H3>
zrangeByScoreWithScores</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt; <B>zrangeByScoreWithScores</B>(byte[]&nbsp;key,
                                                    double&nbsp;min,
                                                    double&nbsp;max)</PRE>
<DL>
<DD>Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).
 <p>
 The elements having the same score are returned sorted lexicographically
 as ASCII strings (this follows from a property of Redis sorted sets and
 does not involve further computation).
 <p>
 Using the optional
 <CODE>LIMIT</CODE> it's
 possible to get only a range of the matching elements in an SQL-alike
 way. Note that if offset is large the commands needs to traverse the list
 for offset elements and this adds up to the O(M) figure.
 <p>
 The <CODE>ZCOUNT</CODE> command is similar to
 <CODE>ZRANGEBYSCORE</CODE> but instead
 of returning the actual elements in the specified interval, it just
 returns the number of matching elements.
 <p>
 <b>Exclusive intervals and infinity</b>
 <p>
 min and max can be -inf and +inf, so that you are not required to know
 what's the greatest or smallest element in order to take, for instance,
 elements "up to a given value".
 <p>
 Also while the interval is for default closed (inclusive) it's possible
 to specify open intervals prefixing the score with a "(" character, so
 for instance:
 <p>
 <code>ZRANGEBYSCORE zset (1.3 5</code>
 <p>
 Will return all the values with score > 1.3 and <= 5, while for instance:
 <p>
 <code>ZRANGEBYSCORE zset (5 (10</code>
 <p>
 Will return all the values with score > 5 and < 10 (5 and 10 excluded).
 <p>
 <b>Time complexity:</b>
 <p>
 O(log(N))+O(M) with N being the number of elements in the sorted set and
 M the number of elements returned by the command, so if M is constant
 (for instance you always ask for the first ten elements with LIMIT) you
 can consider it O(log(N))
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrangeByScoreWithScores(byte[], double, double)">zrangeByScoreWithScores</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>min</CODE> - <DD><CODE>max</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply specifically a list of elements in the specified
         score range.<DT><B>See Also:</B><DD><CODE>#zrangeByScore(String, double, double)</CODE>, 
<CODE>#zrangeByScore(String, double, double, int, int)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double, int, int)</CODE>, 
<CODE>#zcount(String, double, double)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zrangeByScoreWithScores(byte[], double, double, int, int)"><!-- --></A><H3>
zrangeByScoreWithScores</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt; <B>zrangeByScoreWithScores</B>(byte[]&nbsp;key,
                                                    double&nbsp;min,
                                                    double&nbsp;max,
                                                    int&nbsp;offset,
                                                    int&nbsp;count)</PRE>
<DL>
<DD>Return the all the elements in the sorted set at key with a score between
 min and max (including elements with score equal to min or max).
 <p>
 The elements having the same score are returned sorted lexicographically
 as ASCII strings (this follows from a property of Redis sorted sets and
 does not involve further computation).
 <p>
 Using the optional
 <CODE>LIMIT</CODE> it's
 possible to get only a range of the matching elements in an SQL-alike
 way. Note that if offset is large the commands needs to traverse the list
 for offset elements and this adds up to the O(M) figure.
 <p>
 The <CODE>ZCOUNT</CODE> command is similar to
 <CODE>ZRANGEBYSCORE</CODE> but instead
 of returning the actual elements in the specified interval, it just
 returns the number of matching elements.
 <p>
 <b>Exclusive intervals and infinity</b>
 <p>
 min and max can be -inf and +inf, so that you are not required to know
 what's the greatest or smallest element in order to take, for instance,
 elements "up to a given value".
 <p>
 Also while the interval is for default closed (inclusive) it's possible
 to specify open intervals prefixing the score with a "(" character, so
 for instance:
 <p>
 <code>ZRANGEBYSCORE zset (1.3 5</code>
 <p>
 Will return all the values with score > 1.3 and <= 5, while for instance:
 <p>
 <code>ZRANGEBYSCORE zset (5 (10</code>
 <p>
 Will return all the values with score > 5 and < 10 (5 and 10 excluded).
 <p>
 <b>Time complexity:</b>
 <p>
 O(log(N))+O(M) with N being the number of elements in the sorted set and
 M the number of elements returned by the command, so if M is constant
 (for instance you always ask for the first ten elements with LIMIT) you
 can consider it O(log(N))
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrangeByScoreWithScores(byte[], double, double, int, int)">zrangeByScoreWithScores</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>min</CODE> - <DD><CODE>max</CODE> - 
<DT><B>Returns:</B><DD>Multi bulk reply specifically a list of elements in the specified
         score range.<DT><B>See Also:</B><DD><CODE>#zrangeByScore(String, double, double)</CODE>, 
<CODE>#zrangeByScore(String, double, double, int, int)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double)</CODE>, 
<CODE>#zrangeByScoreWithScores(String, double, double, int, int)</CODE>, 
<CODE>#zcount(String, double, double)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zrevrangeByScore(byte[], double, double)"><!-- --></A><H3>
zrevrangeByScore</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrevrangeByScore</B>(byte[]&nbsp;key,
                                              double&nbsp;max,
                                              double&nbsp;min)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrevrangeByScore(byte[], double, double)">zrevrangeByScore</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrevrangeByScore(byte[], byte[], byte[])"><!-- --></A><H3>
zrevrangeByScore</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrevrangeByScore</B>(byte[]&nbsp;key,
                                              byte[]&nbsp;max,
                                              byte[]&nbsp;min)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrevrangeByScore(byte[], double, double, int, int)"><!-- --></A><H3>
zrevrangeByScore</H3>
<PRE>
public java.util.Set&lt;byte[]&gt; <B>zrevrangeByScore</B>(byte[]&nbsp;key,
                                              double&nbsp;max,
                                              double&nbsp;min,
                                              int&nbsp;offset,
                                              int&nbsp;count)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrevrangeByScore(byte[], double, double, int, int)">zrevrangeByScore</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrevrangeByScoreWithScores(byte[], double, double)"><!-- --></A><H3>
zrevrangeByScoreWithScores</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt; <B>zrevrangeByScoreWithScores</B>(byte[]&nbsp;key,
                                                       double&nbsp;max,
                                                       double&nbsp;min)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrevrangeByScoreWithScores(byte[], double, double)">zrevrangeByScoreWithScores</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zrevrangeByScoreWithScores(byte[], double, double, int, int)"><!-- --></A><H3>
zrevrangeByScoreWithScores</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../redis/clients/jedis/Tuple.html" title="class in redis.clients.jedis">Tuple</A>&gt; <B>zrevrangeByScoreWithScores</B>(byte[]&nbsp;key,
                                                       double&nbsp;max,
                                                       double&nbsp;min,
                                                       int&nbsp;offset,
                                                       int&nbsp;count)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zrevrangeByScoreWithScores(byte[], double, double, int, int)">zrevrangeByScoreWithScores</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zremrangeByRank(byte[], int, int)"><!-- --></A><H3>
zremrangeByRank</H3>
<PRE>
public java.lang.Long <B>zremrangeByRank</B>(byte[]&nbsp;key,
                                      int&nbsp;start,
                                      int&nbsp;end)</PRE>
<DL>
<DD>Remove all elements in the sorted set at key with rank between start and
 end. Start and end are 0-based with rank 0 being the element with the
 lowest score. Both start and end can be negative numbers, where they
 indicate offsets starting at the element with the highest rank. For
 example: -1 is the element with the highest score, -2 the element with
 the second highest score and so forth.
 <p>
 <b>Time complexity:</b> O(log(N))+O(M) with N being the number of
 elements in the sorted set and M the number of elements removed by the
 operation
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zremrangeByRank(byte[], int, int)">zremrangeByRank</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zremrangeByScore(byte[], double, double)"><!-- --></A><H3>
zremrangeByScore</H3>
<PRE>
public java.lang.Long <B>zremrangeByScore</B>(byte[]&nbsp;key,
                                       double&nbsp;start,
                                       double&nbsp;end)</PRE>
<DL>
<DD>Remove all the elements in the sorted set at key with a score between min
 and max (including elements with score equal to min or max).
 <p>
 <b>Time complexity:</b>
 <p>
 O(log(N))+O(M) with N being the number of elements in the sorted set and
 M the number of elements removed by the operation
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#zremrangeByScore(byte[], double, double)">zremrangeByScore</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>start</CODE> - <DD><CODE>end</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically the number of elements removed.</DL>
</DD>
</DL>
<HR>

<A NAME="zunionstore(byte[], byte[]...)"><!-- --></A><H3>
zunionstore</H3>
<PRE>
public java.lang.Long <B>zunionstore</B>(byte[]&nbsp;dstkey,
                                  byte[]...&nbsp;sets)</PRE>
<DL>
<DD>Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey. It is mandatory to provide the number of
 input keys N, before passing the input keys and the other (optional)
 arguments.
 <p>
 As the terms imply, the <CODE>ZINTERSTORE</CODE> command requires an element to be present in each of the
 given inputs to be inserted in the result. The
 <CODE>ZUNIONSTORE</CODE> command inserts all
 elements across all inputs.
 <p>
 Using the WEIGHTS option, it is possible to add weight to each input
 sorted set. This means that the score of each element in the sorted set
 is first multiplied by this weight before being passed to the
 aggregation. When this option is not given, all weights default to 1.
 <p>
 With the AGGREGATE option, it's possible to specify how the results of
 the union or intersection are aggregated. This option defaults to SUM,
 where the score of an element is summed across the inputs where it
 exists. When this option is set to be either MIN or MAX, the resulting
 set will contain the minimum or maximum score of an element across the
 inputs where it exists.
 <p>
 <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
 sizes of the input sorted sets, and M being the number of elements in the
 resulting sorted set
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstkey</CODE> - <DD><CODE>sets</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically the number of elements in the sorted
         set at dstkey<DT><B>See Also:</B><DD><CODE>#zunionstore(String, String...)</CODE>, 
<CODE>#zunionstore(String, ZParams, String...)</CODE>, 
<CODE>#zinterstore(String, String...)</CODE>, 
<CODE>#zinterstore(String, ZParams, String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zunionstore(byte[], redis.clients.jedis.ZParams, byte[]...)"><!-- --></A><H3>
zunionstore</H3>
<PRE>
public java.lang.Long <B>zunionstore</B>(byte[]&nbsp;dstkey,
                                  <A HREF="../../../redis/clients/jedis/ZParams.html" title="class in redis.clients.jedis">ZParams</A>&nbsp;params,
                                  byte[]...&nbsp;sets)</PRE>
<DL>
<DD>Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey. It is mandatory to provide the number of
 input keys N, before passing the input keys and the other (optional)
 arguments.
 <p>
 As the terms imply, the <CODE>ZINTERSTORE</CODE> command requires an element to be present in each of the
 given inputs to be inserted in the result. The
 <CODE>ZUNIONSTORE</CODE> command inserts all
 elements across all inputs.
 <p>
 Using the WEIGHTS option, it is possible to add weight to each input
 sorted set. This means that the score of each element in the sorted set
 is first multiplied by this weight before being passed to the
 aggregation. When this option is not given, all weights default to 1.
 <p>
 With the AGGREGATE option, it's possible to specify how the results of
 the union or intersection are aggregated. This option defaults to SUM,
 where the score of an element is summed across the inputs where it
 exists. When this option is set to be either MIN or MAX, the resulting
 set will contain the minimum or maximum score of an element across the
 inputs where it exists.
 <p>
 <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
 sizes of the input sorted sets, and M being the number of elements in the
 resulting sorted set
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstkey</CODE> - <DD><CODE>sets</CODE> - <DD><CODE>params</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically the number of elements in the sorted
         set at dstkey<DT><B>See Also:</B><DD><CODE>#zunionstore(String, String...)</CODE>, 
<CODE>#zunionstore(String, ZParams, String...)</CODE>, 
<CODE>#zinterstore(String, String...)</CODE>, 
<CODE>#zinterstore(String, ZParams, String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zinterstore(byte[], byte[]...)"><!-- --></A><H3>
zinterstore</H3>
<PRE>
public java.lang.Long <B>zinterstore</B>(byte[]&nbsp;dstkey,
                                  byte[]...&nbsp;sets)</PRE>
<DL>
<DD>Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey. It is mandatory to provide the number of
 input keys N, before passing the input keys and the other (optional)
 arguments.
 <p>
 As the terms imply, the <CODE>ZINTERSTORE</CODE> command requires an element to be present in each of the
 given inputs to be inserted in the result. The
 <CODE>ZUNIONSTORE</CODE> command inserts all
 elements across all inputs.
 <p>
 Using the WEIGHTS option, it is possible to add weight to each input
 sorted set. This means that the score of each element in the sorted set
 is first multiplied by this weight before being passed to the
 aggregation. When this option is not given, all weights default to 1.
 <p>
 With the AGGREGATE option, it's possible to specify how the results of
 the union or intersection are aggregated. This option defaults to SUM,
 where the score of an element is summed across the inputs where it
 exists. When this option is set to be either MIN or MAX, the resulting
 set will contain the minimum or maximum score of an element across the
 inputs where it exists.
 <p>
 <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
 sizes of the input sorted sets, and M being the number of elements in the
 resulting sorted set
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstkey</CODE> - <DD><CODE>sets</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically the number of elements in the sorted
         set at dstkey<DT><B>See Also:</B><DD><CODE>#zunionstore(String, String...)</CODE>, 
<CODE>#zunionstore(String, ZParams, String...)</CODE>, 
<CODE>#zinterstore(String, String...)</CODE>, 
<CODE>#zinterstore(String, ZParams, String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="zinterstore(byte[], redis.clients.jedis.ZParams, byte[]...)"><!-- --></A><H3>
zinterstore</H3>
<PRE>
public java.lang.Long <B>zinterstore</B>(byte[]&nbsp;dstkey,
                                  <A HREF="../../../redis/clients/jedis/ZParams.html" title="class in redis.clients.jedis">ZParams</A>&nbsp;params,
                                  byte[]...&nbsp;sets)</PRE>
<DL>
<DD>Creates a union or intersection of N sorted sets given by keys k1 through
 kN, and stores it at dstkey. It is mandatory to provide the number of
 input keys N, before passing the input keys and the other (optional)
 arguments.
 <p>
 As the terms imply, the <CODE>ZINTERSTORE</CODE> command requires an element to be present in each of the
 given inputs to be inserted in the result. The
 <CODE>ZUNIONSTORE</CODE> command inserts all
 elements across all inputs.
 <p>
 Using the WEIGHTS option, it is possible to add weight to each input
 sorted set. This means that the score of each element in the sorted set
 is first multiplied by this weight before being passed to the
 aggregation. When this option is not given, all weights default to 1.
 <p>
 With the AGGREGATE option, it's possible to specify how the results of
 the union or intersection are aggregated. This option defaults to SUM,
 where the score of an element is summed across the inputs where it
 exists. When this option is set to be either MIN or MAX, the resulting
 set will contain the minimum or maximum score of an element across the
 inputs where it exists.
 <p>
 <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
 sizes of the input sorted sets, and M being the number of elements in the
 resulting sorted set
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstkey</CODE> - <DD><CODE>sets</CODE> - <DD><CODE>params</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically the number of elements in the sorted
         set at dstkey<DT><B>See Also:</B><DD><CODE>#zunionstore(String, String...)</CODE>, 
<CODE>#zunionstore(String, ZParams, String...)</CODE>, 
<CODE>#zinterstore(String, String...)</CODE>, 
<CODE>#zinterstore(String, ZParams, String...)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="save()"><!-- --></A><H3>
save</H3>
<PRE>
public java.lang.String <B>save</B>()</PRE>
<DL>
<DD>Synchronously save the DB on disk.
 <p>
 Save the whole dataset on disk (this means that all the databases are
 saved, as well as keys with an EXPIRE set (the expire is preserved). The
 server hangs while the saving is not completed, no connection is served
 in the meanwhile. An OK code is returned when the DB was fully stored in
 disk.
 <p>
 The background variant of this command is <A HREF="../../../redis/clients/jedis/BinaryJedis.html#bgsave()"><CODE>BGSAVE</CODE></A> that
 is able to perform the saving in the background while the server
 continues serving other clients.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="bgsave()"><!-- --></A><H3>
bgsave</H3>
<PRE>
public java.lang.String <B>bgsave</B>()</PRE>
<DL>
<DD>Asynchronously save the DB on disk.
 <p>
 Save the DB in background. The OK code is immediately returned. Redis
 forks, the parent continues to server the clients, the child saves the DB
 on disk then exit. A client my be able to check if the operation
 succeeded using the LASTSAVE command.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="bgrewriteaof()"><!-- --></A><H3>
bgrewriteaof</H3>
<PRE>
public java.lang.String <B>bgrewriteaof</B>()</PRE>
<DL>
<DD>Rewrite the append only file in background when it gets too big. Please
 for detailed information about the Redis Append Only File check the <a
 href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append
 Only File Howto</a>.
 <p>
 BGREWRITEAOF rewrites the Append Only File in background when it gets too
 big. The Redis Append Only File is a Journal, so every operation
 modifying the dataset is logged in the Append Only File (and replayed at
 startup). This means that the Append Only File always grows. In order to
 rebuild its content the BGREWRITEAOF creates a new version of the append
 only file starting directly form the dataset in memory in order to
 guarantee the generation of the minimal number of commands needed to
 rebuild the database.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="lastsave()"><!-- --></A><H3>
lastsave</H3>
<PRE>
public java.lang.Long <B>lastsave</B>()</PRE>
<DL>
<DD>Return the UNIX time stamp of the last successfully saving of the dataset
 on disk.
 <p>
 Return the UNIX TIME of the last DB save executed with success. A client
 may check if a <A HREF="../../../redis/clients/jedis/BinaryJedis.html#bgsave()"><CODE>BGSAVE</CODE></A> command succeeded reading the
 LASTSAVE value, then issuing a BGSAVE command and checking at regular
 intervals every N seconds if LASTSAVE changed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Integer reply, specifically an UNIX time stamp.</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public java.lang.String <B>shutdown</B>()</PRE>
<DL>
<DD>Synchronously save the DB on disk, then shutdown the server.
 <p>
 Stop all the clients, save the DB, then quit the server. This commands
 makes sure that the DB is switched off without the lost of any data. This
 is not guaranteed if the client uses simply <A HREF="../../../redis/clients/jedis/BinaryJedis.html#save()"><CODE>SAVE</CODE></A> and then
 <A HREF="../../../redis/clients/jedis/BinaryJedis.html#quit()"><CODE>QUIT</CODE></A> because other clients may alter the DB data between
 the two commands.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Status code reply on error. On success nothing is returned since
         the server quits and the connection is closed.</DL>
</DD>
</DL>
<HR>

<A NAME="info()"><!-- --></A><H3>
info</H3>
<PRE>
public java.lang.String <B>info</B>()</PRE>
<DL>
<DD>Provide information and statistics about the server.
 <p>
 The info command returns different information and statistics about the
 server in an format that's simple to parse by computers and easy to read
 by humans.
 <p>
 <b>Format of the returned String:</b>
 <p>
 All the fields are in the form field:value
 
 <pre>
 edis_version:0.07
 connected_clients:1
 connected_slaves:0
 used_memory:3187
 changes_since_last_save:0
 last_save_time:1237655729
 total_connections_received:1
 total_commands_processed:1
 uptime_in_seconds:25
 uptime_in_days:0
 </pre>
 
 <b>Notes</b>
 <p>
 used_memory is returned in bytes, and is the total number of bytes
 allocated by the program using malloc.
 <p>
 uptime_in_days is redundant since the uptime in seconds contains already
 the full uptime information, this field is only mainly present for
 humans.
 <p>
 changes_since_last_save does not refer to the number of key changes, but
 to the number of operations that produced some kind of change in the
 dataset.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Bulk reply</DL>
</DD>
</DL>
<HR>

<A NAME="monitor(redis.clients.jedis.JedisMonitor)"><!-- --></A><H3>
monitor</H3>
<PRE>
public void <B>monitor</B>(<A HREF="../../../redis/clients/jedis/JedisMonitor.html" title="class in redis.clients.jedis">JedisMonitor</A>&nbsp;jedisMonitor)</PRE>
<DL>
<DD>Dump all the received requests in real time.
 <p>
 MONITOR is a debugging command that outputs the whole sequence of
 commands received by the Redis server. is very handy in order to
 understand what is happening into the database. This command is used
 directly via telnet.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>jedisMonitor</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="slaveof(java.lang.String, int)"><!-- --></A><H3>
slaveof</H3>
<PRE>
public java.lang.String <B>slaveof</B>(java.lang.String&nbsp;host,
                                int&nbsp;port)</PRE>
<DL>
<DD>Change the replication settings.
 <p>
 The SLAVEOF command can change the replication settings of a slave on the
 fly. If a Redis server is arleady acting as slave, the command SLAVEOF NO
 ONE will turn off the replicaiton turning the Redis server into a MASTER.
 In the proper form SLAVEOF hostname port will make the server a slave of
 the specific server listening at the specified hostname and port.
 <p>
 If a server is already a slave of some master, SLAVEOF hostname port will
 stop the replication against the old server and start the
 synchrnonization against the new one discarding the old dataset.
 <p>
 The form SLAVEOF no one will stop replication turning the server into a
 MASTER but will not discard the replication. So if the old master stop
 working it is possible to turn the slave into a master and set the
 application to use the new master in read/write. Later when the other
 Redis server will be fixed it can be configured in order to work as
 slave.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>host</CODE> - <DD><CODE>port</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="slaveofNoOne()"><!-- --></A><H3>
slaveofNoOne</H3>
<PRE>
public java.lang.String <B>slaveofNoOne</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="configGet(java.lang.String)"><!-- --></A><H3>
configGet</H3>
<PRE>
public java.util.List&lt;java.lang.String&gt; <B>configGet</B>(java.lang.String&nbsp;pattern)</PRE>
<DL>
<DD>Retrieve the configuration of a running Redis server. Not all the
 configuration parameters are supported.
 <p>
 CONFIG GET returns the current configuration parameters. This sub command
 only accepts a single argument, that is glob style pattern. All the
 configuration parameters matching this parameter are reported as a list
 of key-value pairs.
 <p>
 <b>Example:</b>
 
 <pre>
 $ redis-cli config get '*'
 1. "dbfilename"
 2. "dump.rdb"
 3. "requirepass"
 4. (nil)
 5. "masterauth"
 6. (nil)
 7. "maxmemory"
 8. "0\n"
 9. "appendfsync"
 10. "everysec"
 11. "save"
 12. "3600 1 300 100 60 10000"
 
 $ redis-cli config get 'm*'
 1. "masterauth"
 2. (nil)
 3. "maxmemory"
 4. "0\n"
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - 
<DT><B>Returns:</B><DD>Bulk reply.</DL>
</DD>
</DL>
<HR>

<A NAME="configResetStat()"><!-- --></A><H3>
configResetStat</H3>
<PRE>
public java.lang.String <B>configResetStat</B>()</PRE>
<DL>
<DD>Reset the stats returned by INFO
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="configSet(java.lang.String, java.lang.String)"><!-- --></A><H3>
configSet</H3>
<PRE>
public java.lang.String <B>configSet</B>(java.lang.String&nbsp;parameter,
                                  java.lang.String&nbsp;value)</PRE>
<DL>
<DD>Alter the configuration of a running Redis server. Not all the
 configuration parameters are supported.
 <p>
 The list of configuration parameters supported by CONFIG SET can be
 obtained issuing a <A HREF="../../../redis/clients/jedis/BinaryJedis.html#configGet(java.lang.String)"><CODE>CONFIG GET *</CODE></A> command.
 <p>
 The configuration set using CONFIG SET is immediately loaded by the Redis
 server that will start acting as specified starting from the next
 command.
 <p>
 
 <b>Parameters value format</b>
 <p>
 The value of the configuration parameter is the same as the one of the
 same parameter in the Redis configuration file, with the following
 exceptions:
 <p>
 <ul>
 <li>The save paramter is a list of space-separated integers. Every pair
 of integers specify the time and number of changes limit to trigger a
 save. For instance the command CONFIG SET save "3600 10 60 10000" will
 configure the server to issue a background saving of the RDB file every
 3600 seconds if there are at least 10 changes in the dataset, and every
 60 seconds if there are at least 10000 changes. To completely disable
 automatic snapshots just set the parameter as an empty string.
 <li>All the integer parameters representing memory are returned and
 accepted only using bytes as unit.
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameter</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD>Status code reply</DL>
</DD>
</DL>
<HR>

<A NAME="isConnected()"><!-- --></A><H3>
isConnected</H3>
<PRE>
public boolean <B>isConnected</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="strlen(byte[])"><!-- --></A><H3>
strlen</H3>
<PRE>
public java.lang.Long <B>strlen</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sync()"><!-- --></A><H3>
sync</H3>
<PRE>
public void <B>sync</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lpushx(byte[], byte[])"><!-- --></A><H3>
lpushx</H3>
<PRE>
public java.lang.Long <B>lpushx</B>(byte[]&nbsp;key,
                             byte[]&nbsp;string)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="persist(byte[])"><!-- --></A><H3>
persist</H3>
<PRE>
public java.lang.Long <B>persist</B>(byte[]&nbsp;key)</PRE>
<DL>
<DD>Undo a <CODE>expire</CODE> at turning the expire key into
 a normal key.
 <p>
 Time complexity: O(1)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - 
<DT><B>Returns:</B><DD>Integer reply, specifically: 1: the key is now persist. 0: the
         key is not persist (only happens when key not set).</DL>
</DD>
</DL>
<HR>

<A NAME="rpushx(byte[], byte[])"><!-- --></A><H3>
rpushx</H3>
<PRE>
public java.lang.Long <B>rpushx</B>(byte[]&nbsp;key,
                             byte[]&nbsp;string)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="echo(byte[])"><!-- --></A><H3>
echo</H3>
<PRE>
public byte[] <B>echo</B>(byte[]&nbsp;string)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="linsert(byte[], redis.clients.jedis.BinaryClient.LIST_POSITION, byte[], byte[])"><!-- --></A><H3>
linsert</H3>
<PRE>
public java.lang.Long <B>linsert</B>(byte[]&nbsp;key,
                              <A HREF="../../../redis/clients/jedis/BinaryClient.LIST_POSITION.html" title="enum in redis.clients.jedis">BinaryClient.LIST_POSITION</A>&nbsp;where,
                              byte[]&nbsp;pivot,
                              byte[]&nbsp;value)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html#linsert(byte[], redis.clients.jedis.BinaryClient.LIST_POSITION, byte[], byte[])">linsert</A></CODE> in interface <CODE><A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis">BinaryJedisCommands</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="debug(redis.clients.jedis.DebugParams)"><!-- --></A><H3>
debug</H3>
<PRE>
public java.lang.String <B>debug</B>(<A HREF="../../../redis/clients/jedis/DebugParams.html" title="class in redis.clients.jedis">DebugParams</A>&nbsp;params)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getClient()"><!-- --></A><H3>
getClient</H3>
<PRE>
public <A HREF="../../../redis/clients/jedis/Client.html" title="class in redis.clients.jedis">Client</A> <B>getClient</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="brpoplpush(byte[], byte[], int)"><!-- --></A><H3>
brpoplpush</H3>
<PRE>
public byte[] <B>brpoplpush</B>(byte[]&nbsp;source,
                         byte[]&nbsp;destination,
                         int&nbsp;timeout)</PRE>
<DL>
<DD>Pop a value from a list, push it to another list and return it; or block
 until one is available
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - <DD><CODE>destination</CODE> - <DD><CODE>timeout</CODE> - 
<DT><B>Returns:</B><DD>the element</DL>
</DD>
</DL>
<HR>

<A NAME="setbit(byte[], long, byte[])"><!-- --></A><H3>
setbit</H3>
<PRE>
public java.lang.Long <B>setbit</B>(byte[]&nbsp;key,
                             long&nbsp;offset,
                             byte[]&nbsp;value)</PRE>
<DL>
<DD>Sets or clears the bit at offset in the string value stored at key
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>offset</CODE> - <DD><CODE>value</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="getbit(byte[], long)"><!-- --></A><H3>
getbit</H3>
<PRE>
public java.lang.Long <B>getbit</B>(byte[]&nbsp;key,
                             long&nbsp;offset)</PRE>
<DL>
<DD>Returns the bit value at offset in the string value stored at key
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - <DD><CODE>offset</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="setrange(byte[], long, byte[])"><!-- --></A><H3>
setrange</H3>
<PRE>
public long <B>setrange</B>(byte[]&nbsp;key,
                     long&nbsp;offset,
                     byte[]&nbsp;value)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getrange(byte[], long, long)"><!-- --></A><H3>
getrange</H3>
<PRE>
public java.lang.String <B>getrange</B>(byte[]&nbsp;key,
                                 long&nbsp;startOffset,
                                 long&nbsp;endOffset)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="publish(byte[], byte[])"><!-- --></A><H3>
publish</H3>
<PRE>
public java.lang.Long <B>publish</B>(byte[]&nbsp;channel,
                              byte[]&nbsp;message)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(redis.clients.jedis.BinaryJedisPubSub, byte[]...)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public void <B>subscribe</B>(<A HREF="../../../redis/clients/jedis/BinaryJedisPubSub.html" title="class in redis.clients.jedis">BinaryJedisPubSub</A>&nbsp;jedisPubSub,
                      byte[]...&nbsp;channels)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="psubscribe(redis.clients.jedis.BinaryJedisPubSub, byte[]...)"><!-- --></A><H3>
psubscribe</H3>
<PRE>
public void <B>psubscribe</B>(<A HREF="../../../redis/clients/jedis/BinaryJedisPubSub.html" title="class in redis.clients.jedis">BinaryJedisPubSub</A>&nbsp;jedisPubSub,
                       byte[]...&nbsp;patterns)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../redis/clients/jedis/BinaryClient.LIST_POSITION.html" title="enum in redis.clients.jedis"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../redis/clients/jedis/BinaryJedisCommands.html" title="interface in redis.clients.jedis"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?redis/clients/jedis/BinaryJedis.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BinaryJedis.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
